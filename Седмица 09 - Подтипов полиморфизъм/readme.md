# Седмица 09 - Подтипов полиморфизъм

## Какво е полиморфизъм и защо подтипов?
За полиморфизъм можем да дадем следната по-обща дефиниция: "полиморфизъм е свойството на даден обект да приема формата на друг обект". Въпреки, че тази дефиниция не е непременно свързана с програмирането, тя е напълно валидна и за полиморфизма, с който ние ще се занимаваме. Има много видове полиморфизъм, но идеята на всички тях е една и съща - да можем да работим с обекти от един тип, но да имаме различно поведение според вътрешните особености на всеки обект. В обектно-ориентираното програмиране, най-разпространеният вид полиморфизъм е подтиповият полиморфизъм, който ще бъде обект на нашите занимания до края на курса. Освен него обаче ние вече се сблъскахме с още два вида полиморфизъм, а именно т.нар. [ad hoc полиморфизъм](https://en.wikipedia.org/wiki/Ad_hoc_polymorphism), когато говорихме за претоварване на функции (overriding), и [параметричен полиморфизъм](https://en.wikipedia.org/wiki/Parametric_polymorphism), когато говорихме за шаблони. Подтиповият полиморфизъм (subtyping, subtype polymorphism) е вид полиморфизъм, при който всеки един обект от подтип на даден базов тип може да се използва на всички места, където се очаква обект от базовия тип, като едновременно с това продължава да се държи като обект от подтипа. Подтиповият полиморфизъм е в основата на един от `SOLID` принципите, а именно [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle).

## Статично и динамично свързване 
Едно от изискванията да имаме подтипов полиморфизъм е да имаме наследяване или друга подобна форма на създаване на йерархии от типове. То обаче не е достатъчно, трябва ни и още един механизъм - механизма на динамичното свързване. Свързване наричаме изборът на даден метод, който да се извика в дадена ситуация. До сега, всички програми, които сме разглеждали, използваха статично свързване (early binding) - при него методът се избира по време на компилация. С една дума винаги се извиква метода на статичния тип на обекта. Това го видяхме и предния път - ако преобразуваме обект от типа наследник до обект от родителския тип и извикаме метод, който е предефиниран в наследника, се извиква метода на родителя, а не на наследника. Нашата цел е да постигнем динамично свързване (late binding) - при него методът се избира по време на изпълнение. С една дума винаги се извиква метода на динамичния тип на обекта. В C++ по подразбиране свързването на всички методи е статично (за разлика от голяма част от модерните езици за програмиране, при които е динамично), но за щастие има начин да накараме методите да се свързват динамично - това се постига с т.нар. виртуални методи.

## Виртуални методи
Виртуалните методи са специални методи, които имат динамично свързване. За да създадем виаруален метод е нужно единствено да добавим ключовата дума `virtual` в дефиницията на метода. Виртуалността се "наследява", т.е. ако в базов клас сме обявили метод за виртуален, то и в наследниците методът ще бъде виртуален и не е нужно да го указваме изрично. Когато предефинирваме виртуални методи в наследниците на класа, е добра практика да използваме ключовата дума `override` в дефиницията на метода. Сама по себе си тя няма никаква функция, но тя може да се използва само при предефиниране на виртуални методи и служи като маркировка за това, кои методи са виртуални и кои не. Друга полезна ключова дума е `final` - тя се използва по същия начин като `override`, но има допълнителната функция, че забранява на наследниците на класа, в който е дефинирана, да предефинират дадения метод.

Динамичното свързване в C++ работи само през указатели на базовия тип. С други думи, дори да сме маркирали даден метод като виртуален, ако го извикваме директно през обект на базовия клас, свързването ще продължава да е статично. Именно заради това, за да можем да имаме напълно функционален подтипов полиморфизъм, трябва винаги да работим с указатели към базовия тип, а не обекти (в частност, понеже референциите са дереференцирани указатели, можем да имаме подтипов полиморфизъм и чрез тях).

Една важна особеност е, че когато унищожим обект, през указател на типа родител, ако свързването на деструктора не е динамично, ще се извика деструкторът на родителя. Затова не трябва да забравяма да маркираме деструктора в базовия клас като виртуален.

Нека видим и един пример за динамичното свързване в действие:

```c++
#include <iostream>

class Base {
public:
  virtual void do_work() const {
    std::cout << "Base is working\n";
  }

  void say_hi() const {
    std::cout << "Base is saying hi\n";
  }
};

class Derived : public Base {
public:
  void do_work() const final {
    std::cout << "Derived is working\n";
  }

  void say_hi() const {
    std::cout << "Derived is saying hi\n";
  }
};

int main() {
  Derived derived;

  Base derived_as_base = derived;
  derived_as_base.do_work(); // -> Base is working
  derived_as_base.say_hi(); // -> Base is saying hi

  Base* derived_as_base_pointer = new Derived;
  derived_as_base_pointer->do_work(); // -> Derived is working
  derived_as_base_pointer->say_hi(); // -> Base is saying hi

  delete derived_as_base_pointer;
  return 0;
}
```

Начинът, по който се реализира динамичното свързване е чрез виртуални таблици. Сега няма да навлизаме в детайли какво са виртуалните таблици, но ако ви е интересно може да прочетете [тук](https://www.learncpp.com/cpp-tutorial/the-virtual-table/).

## Типова информация по време на изпълнение
В голяма част от модерните езици за програмиране има механизъм за получаване на типова информация по време на изпълнение (`RTTI - Run-time type information`). Чрез нея можем да разберем какъв е типът на даден обект в даден момент по време на изпълнение. В C++ това е възможно чрез оператора `typeid`, който връща обект от тип `std::type_info`, чрез който можем да сравняваме типове на обекти. Да видим и един пример с класовете от горния пример:

```c++
Base base;
Base* derived = new Derived;

std::cout << std::boolalpha << (typeid(base) == typeid(*derived)) << '\n'; // -> false
std::cout << std::boolalpha << (typeid(Derived) == typeid(*derived)) << '\n'; // -> true

delete derived;
```

Проверката на типове по време на изпълнение, въпреки че изглежда полезна, е в разрес с принципите на обектно-ориентираното програмиране и в частност с `Liskov substitution principle`. Разбира се, има някакви изключително редки случаи, в които няма как да си решим проблема без нея, но по принцип ще гледаме да я избягваме в полза на полиморфизма.

Предния път видяхме, че преобразуването на обект от клас наследник към обект от клас родител е напълно легална операция, но обратното може да доведе до проблеми. Ако все пак искаме да го направим, има безопасен начин за това - като използваме `dynamic_cast`. Той се използва, за да преобразуваме указатели към родителски клас към указатели на класове наследници. Ако преобразуването не е възможно, `dynamic_cast` ще върне `nullptr`, а няма да се опита насилсвено да извърши преобразуването. Така можем безопасно да проверим дали можем да конвертираме обекти от тип на родителски клас към тип на клас наследник, но отново ще се опитваме да го ползваме само в случаите, когато не можем да решим проблема чрез полиморфизъм. 

## Задача 01 - Герои
Да се реализира клас `Character`, който да представлява герой в игра. Всеки герой трябва да има име, точки атака и точки живот. Да се реализират следните методи:
- deal_damage_to(Character& other) const - нанася щети по подадения герой;
- take_damage(double points) - поема щети;
- heal(double points) - възвръща точки живот;
- compare_name(const char* name) const - проверява дали героят има същото име като подаденото
- print() const - извежда подробна информация за героя в следния формат:
```
Name: {name}
Type: Ordinary Character
HP: {health_points}
DMG: {damage_points}
```

Да се реализира клас `Knight`, наследник на клас `Character`, който представлява рицар в игра. За разлика от обикновения герой, рицарят блокира 25% от нанесените му щети и възвръща с 5% повече точки живот. Освен това при извеждането на информация за рицаря, да се извежда Knight вместо Ordinary Character.

Да се реализира клас `Archer`, наследник на клас `Character`, който представлява стрелец в игра. За разлика от обикновения герой, стрелецът нанася 33% повече щети, но поема 15% повече щети. Освен това при извеждането на информация за стрелеца, да се извежда Archer вместо Ordinary Character.

Да се реализира клас `Game`, който представлява игра, в която има списък от герои, които се бият помежду си. Да се реализират следните методи:
- add(Character* character) - добавя герой в списъка;
- battle(const char* attacker, const char* target) - героят с име {attacker} напада героя с име {target}. Ако някой от героите не е част от списъка да се изведе подходящо съобщение. Ако точките живот на героя с име {target} паднат под 0, героят да се премахне от списъка и да се изведе подходящо съобщение;
- heal(double amount) - всички герои в списъка възвръщат {amount} точки живот;
- print() const - извежда подробна информация за оцелелите до момента герои.