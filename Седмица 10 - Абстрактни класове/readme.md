# Седмица 10 - Абстрактни класове

## Чисти виртуални методи
Много често, когато наследяваме някакъв базов клас, ние не искаме да имаме обекти от този клас, а искаме да го използваме като общ родител за някаква йерархия от класове, който да обединява общи методи и член-данни за тези класове. В този ред на мисли, ние не искаме да имаме реализация на методите на този клас, а искаме те само да "подсказват" какви методи да очакваме в наследниците му. Ако оставим обаче методите без реализация ще получим грешка по време на компилация - трябва ни друго решение на проблема. Това може да се постигне чрез т.нар. чисти виртуални методи - това са виртуални методи без реализация, които завършват с `= 0`. Те ни освобождават от задължението да реализираме дадените методи, но за сметка на това губим възможността да инстанцираме обекти от класа, в който са дефинирани (което обаче в почти всички случаи не е проблем). Нека да видим пример за такива методи:

```c++
class Base {
public:
  virtual void print() const = 0;
};

class FirstDerived : public Base {
public:
  void print() const final {
    std::cout << "FirstDerived::print()\n";
  }
};

class SecondDerived : public Base {
public:
  void print() const final {
    std::cout << "SecondDerived::print()\n";
  }
};

int main() {
  // Base base; -> compile time error
  FirstDerived fd;
  SecondDerived sd;

  fd.print(); // -> FirstDerived::print()
  sd.print(); // -> SecondDerived::print()
  return 0;
}
```

## Абстрактни класове и интерфейси
Клас, който съдържа поне един чисто виртуален метод се нарича абстрактен клас. Абстрактен е понеже не могат да се създават инстанции от него. Това, което може да се прави обаче е, че могат да се създават указатели към абстрактен клас. Това е ключово, за да може полиморфизмът да продължи да работи, в противен случай нямаше да можем да работим с наследниците по унифициран начин. Ако някой от наследниците на абстрактен клас не предостави реализация на някой от чистите виртуални методи, то той също става абстрактен. 

Един проблем от към стилова гледна точка е това, че абстрактните класове могат да съдържат в себе си член-данни и методи с реализации. Съответно, когато нашите класове ги наследят, те ще продължат да съдържат тези методи и член-данни. Така обаче класовете стават по-тясно свързани с родителския клас и в доста случаи това пречи за лесното им разширяване. Затова при обектно-ориентирания дизайн се предпочита да не се наследяват директно класове, а интерфейси - това са обекти, които дефинират множество от операции, които трябва да се поддържат от типовете, които ги наследяват (или имплементират). В C++ няма отделна структура за интерфейси, но те могат да се моделират чрез абстрактни класове, които съдържат само чисти виртуални методи. Един от `SOLID` принципите - [Dependency Inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle), се основава именно на идеята да се работи с интерфейси, вместо с конкретни имплементации, за да се намалят зависимостите между отделните класове (или модули).

## Проблемът със собствеността на паметта
Предният път видяхме, че когато работим с хетерогенни контейнери (контейнери, състоящи се от елементи от различни типове), се налага да работим с указатели към някакъв общ надтип на типовете на обектите в контейнера. Проблемът, с който се сблъскахме е, че когато добавяхме нови елементи в контейнера, ние добавяхме указателите, които се подаваха като аргументи на методите. Това обаче е в разрез с принципа `RAII - (Resource Acquisition Is Initialization)`. За да спазим този принцип, трябва при получаването на тези указатели да създадем копия на обектите, към които сочат, и да работим с указатели към новите копия. По този начин няма да имаме споделяне на памет и класът ни ще се грижи сам за паметта, с която оперира. Оказва се обаче, че създаването на тези копия не е толкова проста задача, понеже контейнерът работи с указатели към базовия клас и не знаем какъв е истинския тип на обектите, сочени от тези указатели, а като не знаем типа, не знаем на какъв обект трябва да направим копие. Решението в случая е да оставим задачата за копиране на самите обекти. Това се постига като в базовия клас направим метод, който връща указател към копие на обекта, който извиква метода. Този метод стандартно се нарича `clone` и има следния вид:

```c++
class Base {
public:
  // ... more methods and data members
  virtual Base* clone() const {
    return new Base(*this);
  }
};
```

Този метод задължително трябва да е виртуален, за да могат наследниците на класа да предоставят своя имплементация, която ще връща копие на съответния наследник. Създаването на такъв метод е основата на [Prototype design pattern](https://refactoring.guru/design-patterns/prototype).

## Ковариантни типове на връщане
Ковариантните типове на връщане на методи са такива типове, които могат да се заменят от по-конкретен тип, когато методите се предефинират в подкласовете. В C++ ковариантните типове на връщане се постигат като типа на връщане на метод в базовия клас е указател към обект от (потенциално различен) базов клас. По този начин, в класовете наследници можем да заменим типа на връщане с указател към обект от клас наследник и сигнатурата на метода ще продължава да се води същата като тази на метода в базовия клас. Класически пример е методът `clone`, с който се запознахме по-горе:

```c++
class Base {
public:
  // ... more methods and data members
  virtual Base* clone() const {
    return new Base(*this);
  }
};

class Derived : public Base {
  // ... more methods and data members
  Derived* clone() const final {
    return new Derived(*this);
  }
};
```

## Общи изисквания:
За всички класове искаме да е спазен принципът `RAII (Resource Acquisition Is Initialization)`.

## Задача 01 - Герои
Да се реализира клас `Character`, който да представлява герой в игра. Всеки герой трябва да има име, точки атака и точки живот. Да се реализират следните методи:
- deal_damage_to(const Character& other) const - нанася щети по подадения герой;
- take_damage(double points) - поема щети;
- heal(double points) - възвръща точки живот;
- compare_name(const char* name) const - проверява дали героят има същото име като подаденото
- print() const - извежда подробна информация за героя в следния формат:
```
Name: {name}
Type: {character_type}
HP: {health_points}
DMG: {damage_points}
```

Да се реализира клас `Knight`, наследник на клас `Character`, който представлява рицар в игра. За разлика от обикновения герой, рицарят има име на оръженосеца си, блокира 25% от нанесените му щети и възвръща с 5% повече точки живот. Освен това при извеждането на информация за рицаря, да се извежда Knight като тип на героя, както и името на оръженосеца.

Да се реализира клас `Archer`, наследник на клас `Character`, който представлява стрелец в игра. За разлика от обикновения герой, стрелецът нанася 33% повече щети, но поема 15% повече щети. Освен това при извеждането на информация за стрелеца, да се извежда Archer като тип на героя.

Да се реализира клас `Game`, който представлява игра, в която има списък от герои, които се бият помежду си. Героите могат да са само рицари и стрелци. Да се реализират следните методи:
- add(const Character& character) - добавя герой в списъка;
- battle(const char* attacker, const char* target) - героят с име {attacker} напада героя с име {target}. Ако някой от героите не е част от списъка да се изведе подходящо съобщение. Ако точките живот на героя с име {target} паднат под 0, героят да се премахне от списъка и да се изведе подходящо съобщение;
- heal(double amount) - всички герои в списъка възвръщат {amount} точки живот;
- print() const - извежда подробна информация за оцелелите до момента герои.

## Задача 02 - Банка
Да се реализира клас `Account`, който представлява банкова сметка. Всяка банкова сметка има уникален идентификатор, състоящ се от цифри и букви, баланс и лихвен процент. Да се реализират следните методи:
- deposit(double amount) - депозира подадената сума в сметката;
- withdraw(double amount) - ако има достатъчен баланс в сметката, тегли подадената сума от сметката. Иначе изкарва подходящо съобщение;
- add_interest() - увеличава баланса спрямо лихвения процент;
- operator==(const char* id) - проверява дали сметката има подадения уникален идентификатор;
- operator<< - извежда подробна информация за сметката.

Да се реализира клас `CheckingAccount`, който представлява разплащателна сметка. Освен характеристиките на обикновената сметка, разплащателната сметка има и такса за транзакция, която се приспада при всяко теглене.

Да се реализира клас `SavingsAccount`, който представлява спестовна сметка. Освен характеристиките на обикновената сметка, спестовната сметка има и лимит за теглене. Ако при теглене клиент опита да изтегли по-голяма сума от лимита, да се откаже тегленето и да се изведе подходящо съобщение.

Да се реализира клас `SalaryAccount`, който представлява сметка за превод на работна заплата. Освен характеристиките на обикновената сметка, сметката за превод на работна заплата има и месечна заплата. При добавянето на лихвения процент, след увеличаването на баланса да се добави и 5% от работната заплата.

Да се реализира клас `Bank`, който представлява банка, в която има множество банкови сметки. Да се реализират следните методи:
- add(const Account& account) - добавя сметка в банката;
- remove(const char* id) - премахва сметка от банката по подадения уникален идентификатор;
- deposit_to(const char* id, double amount) - към сметката с подадения уникален идентификатор депозира подадената сума;
- withdraw_from(const char* id, double amount) - от сметката с подадения уникален идентификатор опитва да изтегли подадената сума;
- add_interest() - увеличава баланса на всички сметки спрямо лихвения им процент;
- operator<< - извежда подробна информация за сметките в банката.