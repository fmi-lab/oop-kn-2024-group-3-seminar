# Седмица 04 - Оператори

## Оператори в C++
Операторите в С++ всъщност не са нищо повече от функции, за които има специален синтаксис (синтактична захар, `syntaxis sugar`), който ни позволява да ги извикваме подобно на операторите в математиката. По този начин езикът ни позволява да използваме инфиксен запис за някои конкретни функции, което прави кода ни по-лесно четим и разбираем. Тези специални функции имат следната сигнатура:

```c++
T operator@(...Args);
```

Тук `T` е типът на резултата от извикването на оператора, а `@` е символът, който ще се използва при инфиксния запис. Пълния списък на тези символи може да видите [тук](https://en.cppreference.com/w/cpp/language/operators). Има няколко оператора, които се използват в префиксен или постфиксен запис (или и двете), вместо инфиксен, но за тях ще стане дума по-късно. За да можем да напишем оператори за нашите класове обаче, трябва да можем да ги предефинираме (`operator overloading`). Предефинирването на оператори става като използваме същата сигнатура на функцията, но като задължително променим типа на аргументите (промяната на типа на резултата е позволена, но не е достатъчна, за да предефинираме оператора). Освен това има 2 варианта къде да се случи предефинирането - дали да е като глобална функция или като метод на клас. Нека разгледаме двата варианта, за да разберем при какви случаи да ги ползваме.

## Предефиниране на оператори чрез обикновени функции
Ако искаме да предефинираме оператор чрез обикновени (глобални) функции, то тогава поне един от аргументите трябва да е от потребителски дефиниран тип - с една дума не можем да предефинираме оператори върху примитивни типове, когато го правим чрез обикновени функции. Най-общо можем да кажем, че предпочитаме да ползваме обикновени функции, за да предефинираме оператори в следните случаи:
- когато искаме да предефинираме оператор за даден клас, без да променяме дефиницията на класа (или когато не можем да я променяме - например, ако работим с някой клас от външна библиотека);
- когато искаме да предефинираме двуместен оператор, чийто първи аргумент е от примитивен тип - в следващата секция ще разберем защо;

Един проблем, който възниква при този вид предефиниране е, че понеже функцията е външна за нашите класове, то тя няма да има достъп до `private` член-данните и методите им. Затова предефинирането чрез обикновени функции е възможно само, когато `public` методите на класовете ни дават необходимата информация за реализирането на операторите.

## Предефиниране на оператори чрез методи на класове
Можем да предефинираме операторите за даден клас, като просто дефинираме оператора като метод на класа. В този случай обаче, в сигнатурата на оператора трябва да пропуснем първия аргумент. Това се налага, понеже всеки метод на класа получава като първи "скрит" аргумент указателя `this`. Тогава, когато предефинирваме оператор като метод на клас, първият аргумент на този оператор винаги ще бъде от типа на класа. Случаите, в които предпочитам да предефинирваме оператори като методи на клас, са следните:
- когато за реализацията на оператора са ни нужни част от `private` член-данните или методите на класа;
- когато операторът е семантично свързан с класа и би било по-интуитивно операторът да е част от класа (все пак искаме всички свойства на класа да са разположени близко до реализацията му).

## Приятелски функции и класове
Когато избираме къде да предефинираме оператор за даден клас има 1 случай, в който няма правилно място - това е случая, при който операторът се нуждае от `private` член-данните или методите на класа, но очаква като първи аргумент обект от друг клас. Тогава не можем да предефинираме оператора чрез обикновена функция, понеже имаме достъп само до `public` член-данните и методите на класа, но и не можем да го предефинираме като метод, понеже тогава задължително първият аргумент е от типа на класа. Типичен пример за такъв оператор е операторът за извеждане в поток - `<<`. Той има следната сигнатура:

```c++
std::ostream& operator<<(std::ostream&, const T&);
```

Необходимо е първият аргумент да е от тип `std::ostream&`, за да можем да наслагваме такива оператори един след друг, подобно на `std::cout` (например: `std::cout << a << ' ' << b << '\n';`). Много често обаче искаме да изведем в потока част от скритите член-данни на класа, до които нямаме достъп извън него. Решението на този проблем е като използваме т.нар. приятелски функции (`friend functions`). Това са функции, чиято дефиниция започва с ключовата дума `friend`. Приятелските функции се дефинират вътре в даден клас, но при реализацията им не се оказва областта на класа. Характерното за тях е, че нямат като "скрит" първи аргумент `this`, но пък имат достъп до `private` член-данните и методите на класа. 

Освен приятелски функции, в C++ може да имаме и приятелски класове. Подобно на приятелските функции, те имат достъп до `private` член-данните и методите на класа, в който са дефинирани.

**ВАЖНО** Концепцията за приятелските класове и функции нарушава принципите за абстракция и енкапсулация, както и концепцията за [`Силна Кохезия и Слаба Свързаност`](https://ducmanhphan.github.io/2019-10-15-Clean-code-with-class/). Гледайте да избягвате да използвате ключовата дума `friend` до колкото е възможно. Разбира се това не винаги е възможно - освен в горния пример за предефинирането на оператора `<<`, друг пример е при реализацията на итератор на колекция, който ще видим във втората половина на курса. 

## Списък на предефинируемите оператори в C++
Това е списъкът на всички оператори, които могат да се предефинирват в С++ и някои от основните особености, свързани с всеки от тях:
- инфиксни аритметични оператор - +, -, *, /, % - приемат по 2 аргумента и най-често се използват за представяне на някакви аритметични операции;
- префиксни аритметични оператори - +, - - приемат по 1 аргумент и най-често се използват за промяна на знак или посока;
- оператори за присвояване - =, +=, -=, *=, /=, %= - приемат по 2 аргумента, извършват дадената аритметична операция и вместо да върнат новата стойност, я присвояват на първия аргумент и връщат референция към него;
- оператори за инкрементиране и декрементиране - ++ и -- - имат 2 варианта - постфиксен и префиксен. Префиксният има сигнатурата `T& operator++()`, а постфиксния има сигнатурата: `T operator++(int)` (в скобите се слага само типа и не се използва като аргумент).
- оператори за сравнение: ==, !=, <, >, <=, >=, <=> (след C++ 20) - приемат 2 аргумента и се ползват за сравнение на обекти по някакви техни характеристики;
- логически оператори - !, &&, || - първият е префиксен, другите два са инфиксни и приемат по два аргумента. Използват се за логическа аритметика или за проверка за валидност;
- оператори за достъп до данни - [], ., ->, *, &. Първият получава като втори аргумент най-често число, по което се индексира някаква вътрешна структура, другите два се използват за достъп до някакви данни, но се ползват рядко, а последните два са префиксни и се използват за достъп до някаква конкретна стойност;
- оператори за двоична аритметика - &, |, ^, <<, >>, &=, |=, ^=, <<=, >>= - първата половина от тях извършват някаква операция (най-често двоична или друга по-специална) и връщат като резултат новата стойност, а втората половина извършват операцията, записват резултата в първия аргумент и връщат референция към него. Операторите `<<` и `>>` често се използват за работа с потоци, подобно на примера по-горе;
- оператор за извикване на функция - () - позволява на обекта, за който е предефиниран, да се разглежда като функция, т.е. да може да бъде извикван (`callable`). Може да приема прозволен брой аргументи и може дa се предефинира само като метод на клас (чрез него всъщност са реализирани анонимните функции - това са специални обекти, наречени [функтори](https://medium.com/@nishityagi521/functors-in-c-b772e05b69bc), които имат предефиниран оператора ());
- оператори за преобразуване на тип - това са специални оператори, които позволяват да преобразуваме обект, към даден тип. Имат следната сигнатура: `operator {type}(Т);`, където `{type}` е типът, към който искаме да преобразуваме обекта от тип `T`. Обърнете внимание, че няма нужда от тип на резултата, понеже той е същия като типа, към който искаме да преобразуваме;

## Задача 01 - Комплексно число
Да се реализира клас `Complex`, представляващ комплексно число. Да се реализират нужните конструктори, селектори и мутатори. Да се реализират методи за намиране на модула, извеждане на числото във вида `a + bi` и в тригонометричен вид. Да се предефинират следните оператори:
- operator+, operator-, operator*(const Complex&), operator/, operator^ - извършват съответните аритметични операции над 2 комплексни числа и връщат ново комплексно число - резултата от операциите;
- operator+=, operator-=, operator*=, operator/=, operator^= - извършват съответните аритметични операции над 2 комплексни числа и записват резултата в първото число;
- operator*(), operator double() - връщат модула на числото;
- operator<, operator>, operator<=, operator>= - сравняват две комплексни числа по модула им;
- operator==, operator!= - проверяват дали две комплексни числа са равни (две комплексни числа са равни, когато са равни едновременно реалните и имагинерните им части);
- operator<< - извежда комплексно число във вида `a + bi`;
- operator>> - въвежда комплексно число по дадена реална и имагинерна част.

## Задача 02 - Символен низ
Да се реализира клас `String`, представляващ символен низ с произволна дължина. Да се реализират нужните контруктори, селектори и мутатори. Да се реализират следните методи:
- empty - проверява дали низа е празен;
- size - връща размера на низа;
- copy - по подадена дестинация (друг низ) и брой, копира в дестинацията толкова символа, започващи от началото на низа, колкото е подадения брой;
- substr - по подадена начална позиция и брой, връща подниз с начало началната позиция и толкова знака, колкото е подадения брой.

Освен това да се предефинират следните оператори:
- operator[] - връща знак по подадена позиция. Да се реализират константен и неконстантен вариант;
- operator+= - конкатенира два низа или низ и знак и записва резултата в първия низ;
- operator+ - прави същото като operator+=, но връща нов низ, съдържащ резултата;
- operator<, operator>, operator<=, operator>=, operator==, operator!= - сравняват два низа лексикографски;
- operator<< - извежда низ;
- operator* - връща първия знак на низа;
- operator char*() - връща низа като указател.

### Бонус:
Реализирайте operator>> за въвеждане на низ с произволна дължина до срещане на интервал или нов ред.

## Задача 03 - Полином
Да се реализира клас `Polynomial`, представляващ полином от произволна степен. Полиномът да се представи като масив от коефициентите пред всяка степен. Да се реализират нужните контруктори, селектори и мутатори. Да се реализират методи за добавяне и премахване на коефициент. Да се предефинират следните оператори:
- operator() - по подадено число пресмята полинома;
- operator[] - по подадена степен, връща коефициента пред тази степен;
- operator+, operator- - съответно събират и изваждат два полинома и връщат нов полином, съдържащ резултата;
- operator+=, operator-= - същите като operator+ и operator-, но записват резултата в първия полином;
- operator*, operator/ - съответно умножават и делят полином с число и връщат нов полином, съдържащ резултата;
- operator*=, operator/= - същите като operator* и operator/, но записват резултата в първия полином;
- operator==, operator!= - проверяват дали два полинома са еднакви. Два полинома казваме, че са еднакви, ако единият може да се сведе до другия чрез умножение или деление на коефициентите с число. Пример: <div>5х + 7 = 10х + 14</div>
- operator<< - извежда полинома във формат: a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + ... + a<sub>1</sub>x + a<sub>0</sub>, където а<sub>0</sub>, а<sub>1</sub>, ... , а<sub>n</sub> са коефициентите на полинома.

Опитайте се да използвате функциите от по-висок ред `map` и `reduce`, където е възможно.

### Бонус:
Направете operator*, operator*=, operator/, operator/= да работят с два полинома, вместо с полином и число. Разгледайте как може да се реализират operator% и operator%=