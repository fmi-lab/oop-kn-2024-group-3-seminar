# Седмица 05 - Класове и Оператори: допълнение

## Конструктор за преобразуване на тип
Конструкторите с точно 1 аргумент са също специални - освен, че могат да се използват като обикновени конструктори, те се използват, за да се покаже как елемент от типа на параметъра може да се преобразува до елемент от типа на класа. Тези конструктори са полезни, когато на някое място очакваме елемент от даден тип и искаме да подадем елемент от друг тип, без да се налага да пишем отделни функции, които правят преобразуването. Пример за такъв конструктор за класа `String` от предния път:

```c++
class String {
public:
  String(const char *str)
      : data(new char[strlen(str) + 1]{}), capacity(strlen(str) + 1) {
    strcpy(data, str);
  }

  friend std::ostream& operator<<(std::ostream& os, const String& string) {
    return os << string.data;
  }

  // more methods...
private:
  char *data;
  std::size_t capacity;
};

void say_hello(const String& name) {
  std::cout << "Hello, " << name << '\n';
}

int main() { 
  say_hello("Pesho");
  return 0; 
}
```

От примера се вижда, че въпреки, че подаваме символен низ от тип `const char*` на функцията `say_hello`, низът се е преобразувал правилно до `String`. Разбира се, не винаги искаме тези конструктори да се възприемат като конструктори за преобразуване. Например, ако имаме клас `Vector`, представляващ динамичен масив, имащ конструктор приемащ само 1 число, което указва какъв да бъде първоначалния размер на масива, най-вероятно не искаме да го ползваме, за да конвертираме числа към масиви. Това може да се избегне, като пред дефиницията конструктора се използва ключовата дума `explicit`. Да разгледаме именно този пример:

```c++
class Vector {
public:
  explicit Vector(std::size_t initial_capacity) 
    : data(nullptr),
      size(0),
      capacity(initial_capacity) {}

  // more methods...
private:
  int* data;
  std::size_t size, capacity;
};

void print(const Vector& vector) {
  // code goes here...
}

int main() { 
  print(5); // compilation error!
  return 0; 
}
```

## Изброими типове
Много често, докато правим дизайна на нашите класове, се случва така, че за някои от член-данните имаме ограничен брой от възможности за техните стойности. Например, ако имаме клас, описващ филм с неговия жанр, то за жанра може да имаме точно определен набор от стойности - комедия, екшън, анимация и т.н. Един възможен вариант да моделираме такива член-данни е като ги представим като стринг и правим проверка дали подадената стойност съвпада с някоя от допустимите. Но този вариант е груб, досаден за писане и не е съобразен с принципите на ООП - в частност с принципа за абстракция. В тези случаи, по-добрият вариант е да използваме изброими типове (`enum types`). Това са специални типове, които имат точно определен набор от стойности, които могат да бъдат проверени по време на компилация, т.е. не е нужно ние да правим каквито и да е проверки. Още може да си мислим за тях като множества от групирани смислово константи. В C++ има два начина за създаване на такива типове, които в голямата си част си приличат, но имат и някои дребни, но важни, разлики. Единият от тях е, чрез ключовата дума `enum`. Дефиницията на изброим тип в този случай изглежда така:

```c++
enum Genre {
  comedy,
  action,
  animation,
  romance,
  fantasy
};
```

За да използваме стойностите на изброим тип, трябва задължително да използваме оператора за указване на област (`::`). Да разгледаме пример на употреба на изброимия тип от по-горе:

```c++
const char* genre_to_string(const Genre& genre) {
  switch (genre) {
    case Genre::comedy:
      return "comedy";
    case action:
      return "action";
    case animation:
      return "animation";
    case romance:
      return "romance";
    case fantasy:
      return "fantasy";
    }
}

int main() { 
  std::cout << genre_to_string(Genre::action) << '\n'; // -> action
  return 0;
}
```

Вътрешно, стойностите на изброимия тип се представят като цели числа от тип `int`, като първата стойност е 0 и всяка следваща нараства с 1. Можем да променим тези стойности като в дефиницията, срещу стойностите, сложим `= {число}`. Ако не сме сложили наши `=` на всички стойности, то останалите се определят като се вземе последната предефинирана стойност и започнат да се увеличават с 1. Можем да променим типа на стойностите като след името на изброимия тип напишем `: {тип}`, но типът трябва да е изброимо множество, т.е. валидни типове са `int, char, bool (ако имаме само 2 стойности)`, а невалидни са `double, char* и т.н.`. Проблемът на това представяне е, че стойностите на изброимите типове имплицитно могат да се сведат до типа, чрез който са представени. Това може да доведе до комична ситуация от този вид:

```c++
int add(int a, int b) {
  return a + b;
}

int main() { 
  std::cout << add(Genre::animation, 5) << '\n'; // -> 7
  return 0;
}
```

За да избегнем такива недоразумения, трябва да използваме втория вариант за дефиниране на изброим тип - чрез `enum class/struct`. На практика всичко казано по-горе за `enum` е вярно и за `enum class`, но `enum class` забранява конвертирането на стойности от изброимия тип до типа, чрез който са представени. Затова е по-добре да използваме `enum class` в почти всички случаи, когато ни се наложи да създаваме изброими типове.

## Обединения на типове
Има някои случаи, когато ни се иска една променлива да има един тип в даден момент от изпълнението на програмата и съвсем различен тип в друг момент (подобно на динамично типизираните езици). На С++ това може да се постигне, в някаква степен, чрез обединение на типове (`union type`). Декларацията на тип, представляващ обединение на други типове е следната:

```c++
union Number {
  unsigned natural;
  int integer;
  double rational;
};
```

Въпреки, че дефиницията е много подобна на тази на структурите не трябва да се бъркате - изброените член-данни не съществуват едновременно като в структурите, а в даден момент е валидна само една от тези стойности. На практика те споделят обща памет: вместо да се заделя памет за 3 променливи в случая, се заделя памет за променливата с най-голям размер и в даден момент има само една "жива" променлива в този регион от паметта. Да разгледаме и пример за това как се използват:

```c++
Number n { .rational = 5.23};
std::cout << n.rational << '\n'; // -> 5.23
n.integer = 3;
std::cout << n.integer << '\n'; // -> 3
std::cout << n.rational << '\n'; // -> undefined behaviour
```

Ако се опитаме да достъпим член-данна, която не е последната модифицирана член-данна, ще получим недефинирано поведение, макар, че голяма част от компилаторите се опитват да пазят и останалите стойности на член-данните. Обединенията на типове могат и да имат и конструктори, деструктори и статични методи (но по-скоро се замислете дали не искате да направите клас, ако ви потрябват). Класически пример къде се ползват тези типове е при имплементацията на парсери, понеже текста се разделя на токени, чиито типове не са ясни предварително.

## Статични методи и член-данни
До сега разглеждаме класове, в които всички член-данни и методи бяха свързани към конкретни инстанции на класа. Има случаи, в които искаме те да не са свързани към нито една инстанция, а да са глобални за всички инстанции - такива методи или член-данни се наричат статични. Те се дефинират, като на първо място стои ключовата дума `static`. Нека разгледаме по отделно статичните член-данни и методите.

Както казахме, статичните член-данни не са свързани към нито една инстанция, а са глобални за всички инстанции - още казваме, че те са "споделени" между всички инстанции. Да разгледаме следният пример за такива член-данни:

```c++
class Counter {
public:
  static unsigned instances;

  Counter() {
    ++instances;
  }
};
```

Тук член-данната `instances` е статична и играе ролята на брояч на инстанциите от този клас, понеже тя е споделена между всички обекти. Забележете, че не сме я инициализирали в дефинцията на класа. Статичните член-данни могат да се инициализират в класа само, ако са `constexpr`, във всички останали случаи, трябва да ги инициализираме извън класа, при това извън заглавния файл. Това става по следния начин:

```c++
unsigned Counter::instances = 0;

int main() { 
  Counter first;
  std::cout << Counter::instances << '\n'; // -> 1
  Counter second;
  std::cout << second.instances << '\n'; // -> 2
  return 0;
}
```

Забележете, че има два начина за достъпване на статични член-данни - с оператора за указване на област (`::`) и директно през инстанция на класа.

Статичните методи отново не са свързани с конкретна инстанция, а са споделени между всички инстанции. Това означа, че те не получават като първи скрит аргумент указателя `this`. Да разширим класа `Counter` със статичен метод:

```c++
#include <iostream>
class Counter {
public:
  static unsigned instances;

  Counter() {
    ++instances;
  }

  static void print_instances_count() {
    std::cout << "You've created " 
              << instances
              << " instances of the Counter class\n";
  }
};
```

Забелязваме, че за разлика от статичните член-данни, статичните методи могат да имат реализация вътре в класа, но същевременно могат да имат такава и извън него. Начинът, по който се ползват иначе а абсолютно същият:

```c++
unsigned Counter::instances = 0;

int main() { 
  Counter first;
  Counter::print_instances_count(); // -> You've created 1 instances of the Counter class
  Counter second;
  second.print_instances_count(); // -> You've created 2 instances of the Counter class
  return 0;
}
```

Добре е да си зададем въпроса кога е подходящо да ползваме статични член-данни и методи. В много голяма част от случаите, те могат да не са част от някой клас, а да са най-обикновени глобални функции или променливи. Може би единствените добри случаи, в които бихме предпочели статични член-данни и методи пред глобални такива са:
- за да ги свържем смислово с някакъв клас (но тогава може да се замислим дали не можем да го направим чрез `namespace`);
- за да реализираме [Singleton Design Patter](https://refactoring.guru/design-patterns/singleton).

## noexcept
Ако сме сигурни, че дадена функция или метод на клас няма да хвърли изключение (т.е. не се очаква да се случи някоя грешка, след която програмата да не може да се възстанови), то е добра практика да го указваме изрично, като на края на дефиницията на функцията или метода използваме ключовата дума `noexcept`. Тя има и вариант, в който приема в скоби израз, който се оценява до истина или лъжа, но изразът трябва да може да се сметне по време на компилация. Ако не сме сложили `noexcept`, то няма гаранция дали функцията може да хвърли изключение или не. На практика, ако не сложим `noexcept` е същото, като да напишем `noexcept(false)`. Освен, че изричното указване на функция с `noexcept` може да предотврати непредвидени грешки, също така позволява на компилатора да направи някакви оптимизации за нас. Има няколко специални методи и функции, които без да се налага да указваме изрично, са `noexcept`:
- деструкторът - в него е забранено да се хвърлят изключения;
- системно-генерираният конструкторът без параметри, освен ако някой от конструкторите без параметри на член-данните не е изрично написан така, че да може да хвърли изключение;
- системно-генерираният конструкторът за копиране, освен ако някой от конструкторите за копиране на член-данните не е изрично написан така, че да може да хвърли изключение;
- системно-генерираният оператор за присвояване, освен ако някой от операторите за присвояване на член-данните не е изрично написан така, че да може да хвърли изключение;
- `delete` и `delete[]`.

Освен като спецификатор на функции, `noexcept` може да се ползва като оператор, който по подадане функция проверява дали тя не може да хвърли изключение. Пример за това как се ползва `noexcept`:
```c++
class Rational {
public:
  Rational(int, int) noexcept;

  // more methods...
private:
  // member variables...

  void simplify() noexcept;
  int find_gcd() const noexcept;
};

int divide(int a, int b) {
  return a / b;
}

int main() { 
  std::cout << std::boolalpha << noexcept(Rational(2, 3)) << '\n'; // -> true
  std::cout << std::boolalpha << noexcept(divide(2, 3)) << '\n'; // -> false
  return 0;
}
```

## inline
Ключовата дума `inline` се слага в началото на дефиницията на функцията, но нейният смисъл се е променил с годините. В началото тя е служила като инструкция за компилатора да не създава функцията, а да я заменя с нейното тялото на всички места, където се извиква. Това е водело до оптимизации в случаите, когато функциите са твърде малки и прости. С времето обаче компилаторите са се развили и са започнали сами да преценят кога да прилагат тази оптимизация и `inline` е станала безполезна и даже се е игнорирала. В днешно време тя има друга роля - тя се слага само пред функции в заглавен файл, състоящи се само от дефиниция, без реализация, и указва, че функцията може да има 2 или повече различни реализации на 2 или повече различни места в някои от другите файлове. Освен това може да се ползва и за променливи, като има същия смисъл. Ние няма да я използваме, но е хубаво да знаете какво прави, за да може, ако четете някакви стари материали, да не останете с впечатлението, че прави някакви оптимизации за вас.

## Задача 01 - Ястие
Да се реализира клас `Dish`, който представлява ястие в ресторант. Всяко ястие има име, цена, количество и калории. Да се предефенират операторите за вход и изход, както и операторът <, който сравнява две ястия спрямо тяхното отношение цена/количество, а ако те са равни - спрямо калориите.

## Задача 02 - Меню
Да се реализира клас `Menu`, който представлява меню в ресторант. Менюто се състои от произволен брой ястия. Да се реализират методи за добавяне и премахване на ястие по име. В менюто всяко ястие има уникално име. Да се реализират още методи за намиране на ястие по име и за намиране на най-подходящо ястие спрямо подадена цена. Най-подходящото ястие се намира по следния принцип - първо се проверява кои са ястията, които са по-евтини от посочената цена, след това измежду тях се избират тези, които имат най-добро съотношение цена/количество и накрая се избира това, което съдържа най-малко калории. Ако има няколко ястия с еднакъв брой калории, то всяко от тях може да се счита за най-добро. Да се предефинира операторът за изход.

## Задача 03 - Готвач
Да се реализира клас `Cook`, който представлява готвач в ресторант. Готвачът има име, позиция (Kitcher Porter, Junior Chef, Head Chef) и списък от ястия, които може да готви и времето, което му е нужно, за да приготви дадено ястие. Да се реализира метод за добавяне на ястие в списъка и метод, който по подадено име на ястие връща необходимото време за приготвяне (ако ястието не е в списъка да се върне 0). Да се предефинират операторът за изход и операторите -- и ++ (префиксните варианти), които съответно да понижават и повишават готвачът с една степен.

## Задача 04 - Ресторант
Да се реализира клас `Restaurant`, който представлява ресторант. Всеки ресторант си има име, меню и списък от готвачи. Да се реализират методи за добавяне и премахване на готвач, намиране на ястие по име в менюто, намиране на готвач, който най-бързо ще приготви дадено ястие от менюто, изкарване на списък от готвачи по позиция и намиране на най-ценен готвач - това е готвачът, който може да приготвя най-много ястия, които само той знае, а ако има няколко готвача с еднакъв брой, да се върне този, който може да приготвя ястия с най-голяма обща цена. Да се предефинира операторът за изход.

## Пояснение:
Нарочно задачите не са описани твърде строго, за да може вие сами да интерпретирате условията и да реализирате най-правилните според вас методи на класовете. Помислете дали няма някакви общи части между всички задачи, които може да изнесете в отделни класове и да преизползвате.