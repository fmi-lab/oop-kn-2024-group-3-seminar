# Седмица 13 - Линеен едносвързан списък

## Структура на линейния едносвързан списък
Линеен едносвързан списък е структура от данни, която представлява "верига" от елементи, които знаят кой е следващият елемент във веригата. За да се постигне това, елементите на линейния еносвързан списък представляват наредени двойки, където първият елемент от двойката съдържа стойността, която искаме да запазим в структурата, а вторият елемент представлява указател към следващата наредена двойка в списъка (припомнете си защо трябва да бъде указател). Стандартно, тези двойки се реализират по следния начин:

```c++
template <typename T>
struct Node {
  Node(const T& data, Node* next) : data(data), next(next) {}

  T data;
  Node* next;
};
```

Линейният едносвързан списък, като структура от данни, на практика не е нищо повече от една "обвивка" над тези наредени двойки. Единствената важна член-данна, която трябва да съдържа, е указател към първата наредена двойка от веригата, понеже от нея могат да бъдат достъпени всички останали (в зависимост от реализацията, може да съдържа и още член-данни, които да улесняват част от операциите). Линейният едносвързан списък скрива вътрешната реализация на елементите и предоставя на външния свят методи, които вътрешно работят с наредените двойки, но без явното знание на потребителя.

## Сравнение между динамичен масив и линеен едносвързан списък
Линейният едносвързан списък представлява алтернатива на динамичния масив за съхранение на множество от елементи. Отговорът на въпроса защо бихме ползвали едното пред другото се крие в това какви операции се очаква да прилагаме по-често върху техните елементи (на практика това важи за всички структури от данни). Нека да разгледаме предимствата и недостатъците на линейния едносвързан списък спрямо динамичния масив, за да може най-добре да разберем кога бихме предпочели да използваме списък и кога - масив

**Предимства на линейния едносвързан списък:**
- по-бързи операции за добавяне и премахване на елемент в началото на списъка;
- при наличие на итератор - по-бързи операции за добавяне и премахване на елемент след даден елемент или в края на списъка;
- няма излишество на памет при разширяване на списъка;
- по-ефективно съхранение на голям брой данни, понеже отпада нуждата елементите да са разположени последователно в паметта, а може да са "фрагментирани" из цялото адресно пространство.

**Недостатъци на линейния едносвързан списък**:
- по-бавен достъп до произволен елемент от списъка;
- по-бавно обхождане на елементите в списъка, поради това, че са разпръстнати из паметта (губим свойството на [spacial locality](https://en.wikipedia.org/wiki/Locality_of_reference) на кеша);
- изисква повече памет, понеже елементите трябва да заделят памет и за указателя към следващия елемент;
- операциите за добавяне/премахване на елементи разширяват/смаляват размера на списъка всеки път, което в общия случай е бавна операция.

На база на направените сравнения достигаме до следния извод: предпочитаме да ползваме линеен едносвързан списък пред динамичен масив, когато се очаква да имаме повече операции по добавяне/премахване на елементи, но по-малко операции по достъп на елементи, и когато се налага да съхраняваме голямо количество от данни. В практиката обаче доста рядко може да видите използване на свързан списък, понеже недостатъците от към менежирането на паметта указват голямо влияние върху продуктивността на софтуера, а предимствата биват засенчени от по-ефективни структури от данни.

## Задача 01 - Шаблон на линеен едносвързан списък
Да се реализира шаблон на линеен едносвързан списък `LinkedList<T>`. Да се реализират следните методи към него:
- bool empty() const - проверява дали списъкът е празен;
- std::size_t size() const - връща броя на елементите в списъка;
- void print() const - извежда на стандартния изход всички елементи на списъка;
- void insert_first(const T& element) - добавя елемент към началото на списъка;
- void insert_last(const T& element) - добавя елемент към края на списъка;
- void remove_first() - премахва първия елемент на списъка;
- void remove_last() - премахва последния елемент на списъка;
- void append(const LinkedList\<T>& other) - "закача" елементите на подадения списък към текущия като запазва реда им;
- void reverse() - обръща реда на елементите в списъка;
- void unique() - премахва повтарящите се елементи от списъка;
- void filter(std::function<bool(const T&)> predicate) - премахва всички елементи от списъка, които не отговарят на подадения предикат;
- LinkedList\<U> map(std::function<U(const T&)> operation) const - връща нов списък, съдържащ елементите от текущия след прилагането на подадената операция над всеки един от тях;
- U reduce(std::function<U(const T&)> operation, U null_value) const - връща резултата от прилагането на подадената операция върху всеки един от елементите на списъка, натрупвайки го в подадената начална стойност (дясно свиване);
- bool any(std::function<bool(const T&)> predicate) const - проверява дали в списъка има елемент, който отговаря на подадения предикат;
- bool all(std::function<bool(const T&)> predicate) const - проверява дали всички елементи в списъка отговарят на подадения предикат;
- void sort_by(std::function<bool(const T&, const T&)> comparator = std::less\<T>()) - сортира списъка като използва подадената функция за сравнение на елементите;
- void partition(std::function<bool(const T&)> predicate) - пренарежда елементите на списъка, като тези, които отговарят на подадения предикат са в началото, а останалите - в края.

### Забележка:
Всички методи, които по някакъв начин променят реда на елементите в линейния едносвързан списък, да го правят само чрез размяна на кутиите им, а не директно на стойностите.

### Упътване
`std::less<T>` е структура, която има единствен метод `bool operator()(const T& lhs, const T& rhs) const`, който извиква `operator<` за елементи от подадения тип `T`.
