# Седмица 07 - Автоматизирани тестове

## Какво са автоматизираните тестове?
В разработката на един софтуерен продукт главно място заема тестването на продукта. Тестването е форма на контрол на качеството, който в голяма част от случаите се предпочита пред формалното доказателство на коректността на софтуера поради по-лесната имплементация и възможност за разширяване. Именно заради това в днешно време разработката на софтуер наподобява повече физиката, отколкото математиката - коректността се доказва чрез експерименти, а не чрез формални доказателства. Въпреки, че тестването на софтуера не може да ни даде 100% сигурност за коректността му, то ни дава достатъчно голяма сигурност, която да ни позволи да го развиваме по-бързо. 

Автоматизираните тестове (`automated tests`) са инструмент, чрез който можем много лесно да проверим коректността на част от софтуера, без да се налага да правим ръчни тестове (`manual tests`). За целта се използва специален софтуер, който е отделно от софтуера, който се тества. Този специален софтуер се използва, за да се опише какво поведение или какъв резултат се очаква при конкретно събитие или вход. Удобството на автоматизираните тестове идва от това, че можем да си мислим за тях като за един бутон, който веднага при натискането си може да ни каже дали програмата ни е вярна, без да се налага всеки път да правим ръчно тази проверка. Но щом като автоматизираните тестове се реализират чрез специален софтуер, то не трябва ли да имаме тестове и за него (т.е. да имаме тестове за коректността на тестовете) и ако да, то не би ли довело това до омагьосан кръг от тестове? Този въпрос всъщност е причината тази представа за тестовете като бутон за коректност да е невярна - част от тестовете може да очакват грешен резултат или да не описват правилно поведението на софтуера. Затова никога не можем да имаме пълно доверие на тестовете и когато пишем автоматизирани тестове трябва много да внимаваме да ги пишем коректно, спрямо контекста на тествания софтуер.

## Видове автоматизирани тестове
Автоматизираните тестове се делят на най-различни видове спрямо различни фактори - колко голяма част от софтуера тестват, каква част от софтуера тестват, какъв етап от софтуера тестват и много други. Основно тествотете се разделят на функционални и нефункционални - функционалните тестват правилната работа на софтуера, а нефункционалните тестват как софтуера се държи спрямо някакви външни фактори (сигурност, производителност и т.н.) Някои от по-важните видове функционални тестове са:
- `unit tests` - тестват малка част от софтуера (`unit`) независимо от цялата система;
- `integration tests` - тестват взаимодействието и съвместната работа на няколко части от системата;
- `system tests` - тестват взаимодействието на всички компоненти на системата, за да се провери цялостната коректност на софтуера.

А ето и някои от по-важните нефункционални тестове:
- `performance tests` - тестват производителността на системата при определено натоварване или други външни фактори;
- `security tests` - тестват сигурността на системата;
- `stress tests` - тестват поведението на системата при изключително голямо натоварване.

Има и други видове тестове, които са комбинация както от функционални, така и от нефункционални тестове:
- `regression tests` - тестват дали след промяна по системата, старите функционалности продължавата да са коректни и дали характеристиките на системата не са се влошили;
- `end-to-end tests` - тестват цялостната функционалност и производителност на системата от началото до края на ползването ѝ.

Разбира се, това е доста малка част от всички видове автоматизирани тестове. Наличието на толкова много видове тестове е причината да има отделни отдели, които се занимават само с тестване (т.нар. QA отдели). Това не означава обаче, че ние като програмисти не трябва да пишем тестове, даже напротив. Отговорността за правилното функциониране на софтуера е изцяло наше задължение, затова всеки програмист е длъжен да тества написаният от него код. 

В този курс ще се занимаваме само с `unit` тестове и навсякъде, където се изисква да се напишат автоматизирани тестове се подразбира да се напишат `unit` тестове.

## Test driven development
Една много популярна в последно време методология е `Test driven development` методологията. Характерно за нея е, че тестовете за дадена функционалност се пишат преди реализацията на самата функционалност. По този начин изискванията се транслират до тестове, които насочват програмиста към правилното поведение на системата. Този процес представлява цикъл от три повтарящи се фази - писане на неминаващи тестове, писане на точно толкова код, че тестовете да минат, и рефакториране (т.нар. `Red - Green - Refactor` фази). Ползите от `Test driven development` са доста, но някои по-важни от тях са:
- тестовете служат като документация за проекта, понеже описват в детайли поведението на отделните модули и връзката между тях;
- като пишем първо тестовете ние изграждаме модела на интерфейсите на отделните модули преди да сме почнали да ги реализираме;
- фокусирайки се върху тестовете, ние започваме да пишем код, който освен, че е коректен, може да се тества по-лесно;
- ако напишем първо кода и после тестовете ние ще сме пристрастни спрямо тестовете, които пишем - в този случай сме по-склонни да напишем тестове за нещата, които знаем, че работят, вместо да се опитаме да помислим кои сценарии биха счупили написания от нас код.

`Test driven development` е една доста широка тема с много мнения около себе си, но за целите на курса няма да се спираме подробно върху нея. Освен изброените положителни черти, `Test driven development` има и отрицателни такива, така че всеки си преценя кой стил иска да следва.

## Библиотеката `doctest`
Както стана дума по-горе, за да напишем автоматизирани тестове ни трябва специален софтуер. За нашите цели, този специален софтуер ще бъде библиотеката [doctest](https://github.com/doctest/doctest/) - това е библиотека, състояща се от само 1 заглавен файл (такива библиотеки се наричат [STB-style libraries](https://github.com/nothings/stb)), която предоставя набор от инструменти, които да ни помогнат да пишем по-лесно автоматизирани тестове за нашите програми. Няма да се спираме върху пълната документация на библиотеката, но ще засегнем основните неща, които ще ни се наложи да използваме:
- първо трябва да създадем изходна точка за компилация на библиотеката - това става като в `cpp` файл добавим следния ред: `#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN` (това трябва да стане преди `#include "doctest.h"`). Този макрос инициализира библиотеката като предоставя своя реализация на функцията `main()`. Ако искаме да напишем своя версия на `main` трябва да използваме `#define DOCTEST_CONFIG_IMPLEMENT`, но тогава ще загубим `command line` опциите на `doctest`;
- след като инициализираме библиотеката, можем да започнем да пишем своите тестове в `TEST_CASE` макроса. Той приема име, с което ще разпознаваме теста, и в "тялото" му записваме самият тест. Добра практика е `TEST_CASE` да описва цяла една функионалност, която се тества, а вътре в него да използваме `SUBCASE`, за да тестваме тази функционалност в различни ситуации;
- за да направим проверките, от които зависи дали теста минава, използваме `CHECK` макроса, като му подадем като аргумент булевия израз, който искаме да проверим. `doctest` поддържа още много макроси, които правят такива проверки, като тези, които ще ползваме по-често са
    - `CHECK_EQ` - проверява дали два обекта са равни чрез оператора `==`;
    - `REQUIRE` - на практика е същото, като `CHECK`, но ако условието не е изпълнено, останалите проверки няма да се изпълнят и теста ще приключи веднага;
    - `CHECK_THROWS` - проверява дали подаденият израз хвърля изключение - `CHECK_THROWS_AS` проверява и вида на хвърленото изключение;
    - `CHECK_NOTHROW` - проверява дали подаденият израз не хвърля изключение.

Нека видим пример как всички тези макроси се обединяват в един цял `test case`: 

```c++
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "../libs/doctest.h"

int factorial(int n) {
  int product = 1;

  for(std::size_t i = 1; i <= n; ++i) {
    product *= i;
  }

  return product;
}

TEST_CASE("factorial returns correct values") {
  SUBCASE("factorial(0) should return 1") {
    int result = factorial(0);

    CHECK_EQ(result, 1);
  }

  SUBCASE("factorial(n) should return n! for n >= 0") {
    int result = factorial(5);

    CHECK_EQ(result, 120);
  }

  SUBCASE("factorial(n) should throw std::invalid_argument exception for n < 0") {
    CHECK_THROWS_AS(factorial(-2), std::invalid_argument);
  }
}
```

Сега, ако компилираме файла по същия начин както го правихме до сега, ще получим съобщение, че всички тестове са минали успешно. Нека да добавим следния тест:

```c++
SUBCASE("factorial(n) should throw std::invalid_argument exception for n < 0") {
  CHECK_THROWS_AS(factorial(-2), std::invalid_argument);
}
```

Ако компилираме отново, програмата ще забие. Ако терминираме така забилата програма, ще получим подробно съобщение, съдържащо информация кой `test case` е забил, и ще видим, че един тест не е минал успешно. В случая може да не сме имали намерение да обработваме този случай, но след като написахме теста, вече имаме шаблон за това какво очакваме да се случи при този вход. 

## Задача 00 - Символен низ
Да се реализират автоматизирани тестове за класа `String` от седмица 04.

## Задача 01 - Множество
Да се реализира клас `Set`, който предтставлява множество от елементи от произволен тип. Характерно за множеството е, че всеки елемент в него е уникален. Да се реализират методи за добавяне и премахване на елемент от множеството и проверка дали елемент е част от множеството. Да се реализират следните оператори:
- operator+, operator+= - извършват обединение на 2 множества (A U B)
- operator-, operator-= - от първото множество премахват елементите от второто (А \ B)
- operator*, operator*= - извършват сечение на 2 множества (A ∩ B)

Да се напишат автоматизирани тестове за класа.

## Задача 02 - Кола
Да се реализира клас `Car`, който представлява кола, която има марка, модел, идентификационен номер (номер на рамата), средна скорост и изминато разстояние. Идентификационният номер на всяка кола се определя от реда ѝ на създаване. Да се реализира метод `drive`, който пресмята за колко часа колата ще измине подаденото разстояние. След всяко извикване на `drive` да се актуализира изминатото разстояние. Освен това за всеки 100 изминати километра, средната скорост на колата намалява с 1 км/час, но не може да падне под 50% от първоначалната скорост. Да се реализират оператор ==, който проверява дали 2 коли са от един и същи модел и марка, и операторите за вход и изход. Да се напишат автоматизирани тестове за класа, без операторите за вход и изход.

### Бонус:
С помощта на `std::stringstream` да се напишат автоматизирани тестове и за операторите за вход и изход.

## Задача 03* - Logger
Да се реализира клас `Logger`, който записва съобщения в текстови файлове. Класът трябва да има само една инстанция. Да се реализират 3 метода - `log, error и debug`, които да записват съобщения съответно в три текстови файла - `log.txt, error.txt и debug.txt`. Да се предефинира операторът за изход, който да прави същото като метода `log`. (Сигнатурата на метода да е следната: `Logger& operator<<(const char* message)`).

### Упътване:
Щом като класът трябва да има само една инстанция, то той трябва да следва Singleton Design Pattern. Един възможен начин за имплементирането му е като конструкторът се направи private, а конструкторът за копиране и операторът = се изтрият (това става като след дефиницията им напишем `= delete`). Тогава, за да създадем инстанция на класа, може да си направим публичен метод `get_instance`, който съдържа статична променлива от тип `Logger`, която представлява единствената инстанция на класа. Единственото, което методът `get_instance` ще прави е да връща тази статична променлива. По този начин при първото извикване на `get_instance`, статичната променлива ще се инициализира, а при всяко следващо само ще се връща инстанцията. Понеже не искаме при всяко извикване на методите `log, error и debug` да отваряме наново файловете, в класа може пазим 3 член-данни за 3-те файла като при първото извикване на `get_instance` ще ги отваряме. Това от своя страна означава, че въпреки че изтрихме конструктора за копиране и операторът =, ще ни е нужен деструктор, който да затваря файловете. Това е един от малкото случаи, който е изключение от правилото за голямата четворка.