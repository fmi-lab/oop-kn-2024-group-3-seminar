# Седмица 08 - Наследяване

## Какво е наследяване?
Наслeдяването е един от основните принципи на обектно-ориентираното програмиране. Това е начин за класовете да получат същите член-данни и методи от други класове (буквално ги "наследяват"). Чрез наследяване можем да създаваме сложни йерархии от класове, които имат общи реализации на част от методите си и имат член-данни с еднакви имена и типове. От една страна, това улеснява разработването на такива класове, понеже не е нужно да ги реализираме от нулата. От друга страна, това ни позволява да споделяме поведение между класовете и е едно от изискванията да имаме подтипов полиморфизъм в обектно-ориентираните езици.

## Модификатори за достъп и наследяване
Вече разгледахме някои модификатори за достъп - `public` и `private`. В същност има и трети модификатор, който обаче има смисъл само, когато използваме наследяване - това е модификаторът `protected`. Когато член-данни или методи се маркират като `protected` те се държат като `private` в класа, в който са дефинирани. Когато обаче класът, в който са дефинирани, бива наследен, в класа наследник те се държат като `public`. В голяма част от случаите `protected` методи и член-данни са в разрес с принципите за енкапсулация и абстракция и затова ще гледаме да ги избягваме, но има случаи, при които няма начин да моделираме желаното от нас поведение, ако не използваме `protected`.

В C++ има 3 вида наследяване: `public, private и protected`. Те определят видимостта на наследените член-данни и методи. За референция може да използваме следната таблица:

![inheritance types](table-class.png)

Нека да видим и един пример за наследяване в С++:

```c++
#include <iostream>

class Parent {
public:
  void print();
private:
  int a;
  double b;
};

class Child : public Parent {
public:
  void read();
private:
  char c;
};

int main() {
  Child child;

  child.print(); // OK
  child.read(); // OK
  child.a; // Compile time error

  return 0;
}
```

## Преобразуване на типове
Когато един клас наследява друг, обектите на класа наследник могат да се преобразуват (кастнат) към обекти на класа родител. В този случай обаче губим всички методи и член-данни, които присъстват само в класа наследник. Обратното преобразуване обаче не е коректно, понеже обектите на класа родител може да нямат някои от член-данните или методите, които са характерни само за класа наследник. В някои случаи, ако използваме оператора за преобразуване на тип (или т.нар. `C-style case`), няма да получим компилационна грешка, но ще получим грешка по време на изпълнение. Затова по-добрият вариант е да използваме `static_cast` както за този вид преобразувания, така и за преобразувания между прости типове. На практика, този оператор не прави нищо по-различно от обикновения оператор за преобразуване, но ако преобразуването е невъзможно, дава компилационна грешка във всички случаи. 

## Предефиниране на методи
Освен, че можем да наследяваме методи от други класове, можем да променяме поведението на наследените методи. Това се нарича предефиниране на методи (`overriding`, да не се бърка с `overloading`). За да предефинираме метод, в класа наследник трябва да дефинираме метод с абсолютно същата сигнатура като тази на метода, който искаме да предефинираме. Когато през обект на класа наследник извикаме метода, ще се изпълни предефинираната версия. Ако обаче преобразуваме този обект към типа на класа родител и извикаме метода, ще се изпълни версията в класа родител. Следващия път ще видим как можем да извикаме предефинираната версия от обект от типа на родителя, но за сега е важно да разберем, че ако само предефинираме метода, няма да е достатъчно. Ако при предефинирането на метода искаме да извикаме метода от класа родител, можем да го направим като извикаме метода чрез оператора за достъп до област на родителя. Нека разгледаме пример:

```c++
class Parent {
public:
  void print(){
    std::cout << "hi";
  }
};

class Child : public Parent {
public:
  void print() {
    Parent::print();
    std::cout << " how are you";
  }
};

int main() {
  Child child;
  child.print(); // -> hi how are you
  static_cast<Parent>(child).print(); // -> hi
  return 0;
}
```

## Задача 01 - Животни
Да се реализира клас `Animal`, който представлява животно, което има име, възраст и тегло. Да се реализира метод `print`, който извежда подробна информация за животното.

Да се реализира клас `Feline`, който представлява животно от семейство котки. Освен характерните за животното член-данни, класът да има още и брой оставащи животи. Да се предефинира методът `print`, който да извежда подробна информация за животното от семейството на котките.

Да се реализира клас `Cat`, който представлява котка. Освен характерните за животно от семейство котки член-данни, класът да има и име на собственик. Да се предефинира методът `print`, който да извежда подробна информация за котката.

## Задача 02 - Университет
Да се реализира клас `Person`, който представлява човек с име, възраст и имейл. Да се реализират следните методи:
- print - извежда подробна информация за човека;
- send_mail - по подадено съобщение (стринг) добавя съобщението в текстов файл с името на имейла на човека, като то трябва да започва със: `"To {name}: "`;
- view_inbox - изкарва на екрана съобщенията пратени на имейла на човека;

Да се реализира клас `Student`, който представлява студент в университет. Освен характеристиките на човека, студента да има още и факултетен номер. Да се предефинират методите `print` и `send_mail`, които съответно да извеждат подробна информация за студента и да пращат съобщение, което да започва със: `"To {name}, {faculty_number}:"`.

Да се реализира клас `Lecturer`, който представлява лектор в университет. Освен характеристиките на човека, лекторът да има още и име на катедра, от която е част. Да се предефинират методите `print` и `send_mail`, които съответно да извеждат подробна информация за лектора и да пращат съобщение, което да започва със: `"To {name}, part of the {department_name} department:"`.

Да се реализира клас `University`, който представлява университет, който има име, списък от студенти и списък от лектори. Да се реализират следните методи:
- add_student - добавя студент към университета;
- add_lecturer - добавя лектор към университета;
- remove_student - по име на студент го премахва от университета;
- remove_lecturer - по име на лектор го премахва от университета;
- print - изкарва подробна информация за университета и хората в него;
- send_mail_to_student - по подадено съобщение, изпраща имейл с това съобщение до всички студенти;
- send_mail_to_lecturers - по подадено съобщение, изпраща имейл с това съобщение до всички лектори;
- send_mail_to_all - по подадено съобщение, изпраща имейл с това съобщение до всички хора, които са част от университета;