# Седмица 14 - Итератори

## Шаблонът Итератор
Итератор е шаблон за дизайн, който ни предоставя единен интерфейс за обхождане на елементите на произволни колекции без да се интересуваме от вътрешното представяне на елементите. На практика, итераторът представлява отделна структура, която съхранява единичен елемент от колекцията, която обхожда, като той трябва да "знае" кой е следващият елемент, който трябва да бъде обходен. Ние вече се запознахме с най-простите итератори в курса по Увод в програмирането - това бяха указателите към масиви. Те отговарят на горните 2 условия - указателят на практика "съдържа" сочения от него елемент и можем да достъпим следващия елемент като го инкрементираме. Именно затова можехме да използваме функциите `std::begin` и `std::end` върху масиви - това са функции, които връщат итератори към първия елемент и след последния елемент на подадената колекция. Ако искаме те да работят и за наши колекции, то те трябва да съдържат методите `begin` и `end` (std::begin и std::end просто извикват методите begin и end).

## Range-based for loop
В C++ има опростен начин за обхождане на колекции, за които има реализиран итератор - това е т.нар. `range-based for loop`. Той има следния вид:

```c++
int arr[] = {1, 2, 3, 4, 5};

for(int x : arr) {
  std::cout << x << ' ';
}
```

Този вид цикъл всъщност е синтактична захар за следния запис:

```c++
auto begin = std::begin(arr);
auto end = std::end(arr);
for(; begin != end; ++begin) {
int x = *begin;
  std::cout << x << ' ';
}
```

В случая `auto` е типът на итератора, върнат от `std::begin` и `std::end`. От тук вече се вижда, че минималният интерфейс, който трябва да имплементират итераторите на колекциите, така че да могат да бъдат използвани с `range-based for loop` е следният:
- iterator_type& operator++() - служи за достъпване на следващия елемент;
- bool operator!=(const iterator_type& other) const - служи за проверка дали елементите, сочени от 2 итератора са различни;
- \[const\] element_type& operator*() \[const\] - служи за \[константен\] достъп до елемента, сочен от итератора.

Забележка: `iterator_type` и `element_type` не са конкретни типове, а означения съответно за типа на итератора и типа на елементите на обхожданата колекция. Нарочно не са изразени чрез шаблони, защото по-нататък ще видим, че това ще доведе до някои проблеми и особености. 

Освен това, за да работи горния цикъл с нашите колекции, те освен, че трябва да имат съответния итератор, трябва да поддържат и 2 допълнителни метода:
- iterator_type begin() const - връща итератор към първия елемент на колекцията;
- iterator_type end() const - връща итератор след последния елемент на колекцията.

Забележка: за да работи `range-based for loop` за нашите колекции, трябва горните сигнатури на методите да бъдат спазени **точно** - това включва `const` и `&`, където е необходимо.

## Задача 01 - Итератори за сортиран масив
Реализирайте итератор за класа `Sorted` от Седмица 06. Итераторът трябва да реализира необходимите методи, така че да можем да използваме `range-based for loop` за класа. Реализирайте втори итератор за същия клас, който обхожда елементите в обратен ред.

## Задача 02 - Итератор за линеен едносвързан списък
Реализирайте итератор за линейния едносвързан списък, който реализирахме предния път. Итераторът трябва да реализира необходимите методи, така че да можем да използваме `range-based for loop` за класа. Освен това добавете следните методи към списъка, които да работят с вашия итератор:
- void insert_after(const T& element, const LinkedListIterator\<T\>& position) - добавя елемент в списъка след подадената позиция;
- void insert_before(const T& element, const LinkedListIterator\<T\>& position) - добавя елемент в списъка преди подадената позиция;
- void remove_before(const LinkedListIterator\<T\>& position) - премахва елемента след този, сочен от подадения итератор;
- void remove_at(const LinkedListIterator\<T\>& position) - премахва елемента на подадената позиция;
- void remove_after(const LinkedListIterator\<T\>& position) - премахва елемента преди този, сочен от подадения итератор;
- LinkedListIterator\<T\> find_by(std::function<bool(const T&)> predicate) const - връща позицията на първия елемент отговарящ на подадения предикат. Ако такъв елемент не съществува да се върне невалидна позиция.

## Задача 03** - Трансформиращ итератор
Реализирайте итератор за линейния едносвързан списък, който при обхождането на елементите прилага подадена функция върху тях.

Забележка: понеже вече реализирахме итератор за линейния едносвързан списък, няма да можем да използваме този итератор в `range-based for loop`. За да го направим, трябва да реализираме нов шаблонен клас - `Range<Iterator>`, който получава като типов аргумент тип на итератор. Този клас трябва съдържа като член-данни итератори към началото и след края на някаква колекция. Сега вече ще можем да създадем инстанция на този клас, в която типовият аргумент е заменен с типа на нашия трансформиращ итератор и в конструктора на `Range` подадем трансформиращи итератори към началото и след края на свързания списък.

Линк към примерна реализация на доц. д-р Калин Георгиев по време на лекции в курса по Обектно-ориентирано програмиране на спец. Информационни системи от 2020 година: https://github.com/stranxter/lecture-notes/blob/master/samples/02_oop/2020_is/iterators/ranges.cpp