# Седмица 01 - Функции от по-висок ред и шаблони на функции

## Функции от по-висок ред
Функциите от по-висок ред са функции, които отговарят на поне едно от следните 2 условия:
- приемат функция като аргумент
- връщат функция като резултат

Концепцията за функции от по-висок ред е една от най-старите в областта на изчислимостта и компютърните науки като цяло. Нейните основи са заложени в теорията за ламбда-смятането ([lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)) и са характерни най-вече за функционалните езици за програмиране. Въпреки това, на практика всички модерни езици, дори обектно-ориентираните, поддържат функции от по-висок ред поради тяхната силна изчислителна мощ.

Вие вече сте се сблъсквали с функции от по-висок ред извън програмирането. Например, `диференцирането` и `интегрирането` са типични функции от по-висок ред в анализа: те приемат една функция и връщат нова функция - съответно производната и примитивната функция на подадената.

## Функциите като стойност
За да може един език за програмиране да поддържа функции от по-висок ред, те трябва да са първокласни обекти в езика (first-class citizens), т.е. да можем да работим с тях като със стойности - да можем да ги присвояваме на променливи, да ги подаваме на функции и да ги връщаме като резултат от функции. В C++ това се постига като използваме указатели. Указателите са изключително мощно и универсално средство, поради това, че те могат да сочат на практика всякакви обекти в паметта. Функциите се представят в паметта като поредица от машинни инструкции, затова ние можем да насочим указател към първата инструкция от функцията и така на практика ще можем да изпълняваме инструкциите, като ги достъпим през указателя. Това е доста просто обяснение за това как можем да реферимаме функции в паметта, но за нашите цели няма да задълбаваме повече. За щастие, C++ ни предоставя по-високо ниво на абстракция и не е нужно ръчно да намираме адреса на инструкциите на функциите. Вместо това, можем да насочим указател към функция по следния начин:

```c++
double sum(double a, double b) {
  return a + b;
}

int main() {
  double(*f)(double, double) = &sum;
  std::cout << f(1,2) << '\n';
  return 0;
}
```

Нека сега да разгледаме по-внимателно какво точно представлява този запис. Както всички останали указатели, указателите към функции трябва да имат тип. Този тип се определя от типа на резултата и от типовете на аргументите на функцията. На първо място стои типът на резултата - в нашия случай `dpuble`. След това в скобите слагаме името на указателя, като трябва преди името да има `*`. След това в скоби изброяваме типовете на аргументите. Накрая, за да присвоим адреса на функцията, можем да използваме `&` по същия начин, по който правим и за останалите стойности. Както виждате, този запис е меко казано неприятен, затова в повечето случаи ще даваме имена на тези типове на най-високото ниво в нашите програми. Това се постига по следния начин:

```c++
using BinaryOperation = double(*)(double, double);

double sum(double a, double b) {
  return a + b;
}

int main() {
  BinaryOperation f = &sum;
  std::cout << f(1,2) << '\n';
  return 0;
}
```

Ключовата дума `using` в случая се използва за даване на ново име на тип. Това е просто за удобство, за да не работим директно с неприятните типове на указателите към функции, но също така може да се използва, за да дадем някаква семантика на типовете. По нататък в курса ще видим и други приложения на `using`.

След като вече видяхме как да работим с функциите като със стойности, да видим един пример за функция от по-висок ред:

```c++
using UnaryOperation = double(*)(double);

double twice(UnaryOperation operation, double n) {
  return operation(operation(n));
}

double square(double n) {
  return n * n;
}

int main() {
  std::cout << twice(square, 2) << '\n';
  return 0;
}
```

## Анонимни функции
Въпреки усилията, които положихме, за да опростим работата с функции от по-висок ред, все още има няколко проблема. Единият е, че всеки път, когато искаме да подадем функция като аргумент, трябва да напишем дефиницията и тялото на функцията на най-високото ниво в програмата. Тук на помощ идват анонимните функции (още познати като ламбда функции): това е начин да създадем функция "на място" без да се налага да пишем изрично нейна дефиниция. Наричат се анонимни, понеже не им даваме име и не се пазят в паметта, подобна на литералите. Да разгледаме примера от преди малко с използването на анонимни функции:

```c++
using UnaryOperation = double(*)(double);

double twice(UnaryOperation operation, double n) {
  return operation(operation(n));
}

int main() {
  double result = twice([](double n) -> double {
    return n * n;
  }, 2);

  std::cout << result << '\n';
  return 0;
}
```

Резултатът от изпълнението е същият като по-горе. Нека да разгледаме отделно самата анонимна функция, за да я разберем по-лесно:

```c++
[](double n) -> double {
  return n * n;
}
```

Квадратните скоби са т.нар. `capture`. В него може да изброяваме променливи, чиите дефиниции са извън тялото на анонимната функция, но които се използват в тялото на функцията. Алтернативно можем да напишем `=`, за да използваме всички променливи, дефинирани над функцията. Можем да използваме и `&` - това е същото като да ползваме `=`, но тогава може да ги ползваме по референция в тялото на функцията, т.е. можем да ги променяме. След това в скоби се изброяват аргументите на функцията, по същия начин като при обикновените функции. Типът след стрелката е типът на резултата. Характерното за него е, че може да го пропускаме (и ние най-често това ще правим). Накрая, в къдрави скоби е тялото на функцията.

Един проблем на анонимните функции е, че когато имаме променливи в `capture` те всъщност не се интерпретират като обикновени функции, а като функции със състояние. Тогава типът на функцията става неизвестен за нас (защо, ще разберем по нататък в курса). За да избягаме от този проблем можем да им дадем тип `auto` - това е универсален тип, който ни освобождава от задължението изрично да дадем тип и оставя компилаторът сам да се "сети" какъв е типът. Друга алтернатива е да ползваме `std::function`, но това ще го видим след няколко седмици.

Сега вече имаме нужните знания, за да напишем функция, която връща функция като резултат. Нека да видим отново примера за функцията `twice`, но сега вместо да подаваме втори аргумент, ще връщаме функция на 1 аргумент:

```c++
using UnaryOperation = double(*)(double);

auto twice(UnaryOperation operation) {
  return [operation](double n){
    return operation(operation(n));
  };
}

int main() {
  auto result = twice([](double n){
    return n * n;
  });

  std::cout << result(2) << '\n';
  return 0;
}
```

**ВАЖНО**: Не използвайте `auto` никъде другаде, освен при работа с анонимни функции. Освен, че е лош стил да оставяме компилаторът да си изведе типовете, в някои случаи той може да не успее и да получим неочаквани грешки по време на изпълнение (а и ще получите 0 точки при оценяване :)).

## Шаблони на функции
Понякога искаме да напишем такива функции, които имат абсолютно една и съща логика за всички типове (или поне някакво множество от типове). Пример за такава функция е функцията `swap`:

```c++
void swap(int& a, int& b) {
  int tmp = a;
  a = b;
  b = tmp;
}
```

В случая сме я написали за аргументи от тип `int`, но дори те да бяха от тип `double` или `char`, тялото на функцията ще е същото. Тук на помощ идват шаблоните на функции. Те ни позволяват да напишем дефиниции за функции, които не зависят от типа на аргументите. Ето как би изглеждала функцията `swap`, ако я дефинираме с шаблон:

```c++
template <typename T>
void swap(T& a, T& b) {
  T tmp = a;
  a = b;
  b = tmp;
}

int main() {
  int a = 5, b = 3;
  swap<int>(a, b);

  double c = 3.14, d = 6.28;
  swap<double>(c, d);

  std::cout << a << ' ' << b << '\n';
  std::cout << c << ' ' << d << '\n';
}
```

Тук типът `T` не е конкретен тип, а просто означение за типа на аргументите. Когато извикваме функцията в `<>` пишем конкретния тип на аргументите. В повечето случаи няма да го пишем обаче, понеже компилаторът е достатъчно умен, за да си го изведе сам по типа на подадените аргументи. Важно нещо, което трябва да запомним е, че шаблоните на функции не са функции - това са по-скоро инструкции за компилатора как трябва да изглеждат функциите. При компилация, за всяко извикване на такава функция, компилаторът създава нова функция, която е с конкретните типове на подадените аргументи. По нататък ще разгледаме в детайли шаблоните, но това ще бъде към средата на семестъра.


## Задача 01 - Неподвижна точка
Напишете шаблон на функция `is_fixed_point`, която приема аргумент от тип `T` и функция на 1 аргумент от тип `T`. Функцията `is_fixed_point` да проверява дали подаденият аргумент е неподвижна точка на подадената функция (`x` е неподвижна точка на `f`, ако `f(x) = x`).

### Пример:
```c++
std::cout << std::boolalpha << is_fixed_point<int>([](int n){ return n * 5;}, 0) << '\n'; // -> true
std::cout << std::boolalpha << is_fixed_point<int>([](int n){ return n * 5;}, 2) << '\n'; // -> false
```

## Задача 02 - Композиция
Напишете шаблон на функция `composition`, която приема функция `f` на 1 аргумент от тип `T`, която връща стойност от тип `U`, и функция `g` на 1 аргумент от тип `U`, която връща резултат от тип `S`. Функцията `composition` да връща нова функция, която е композицията на `f` и `g`.

### Пример:
```c++
std::cout << composition<int, int, int>([](int x){ return x + 1;}, 
                                        [](int x){ return x * 2;})(5) << '\n'; // -> 12
```

## Задача 03 - N-кратна композиция
Напишете шаблон на функция `repeat`, която приема функция `f` на 1 аргумент от тип `T`, която връща стойност от тип `Т`, и естествено число `n`. Функцията `repeat` да връща нова функция, която представлява `n`-кратната композиция на `f`.

## Задача 04 - Производна
Напишете шаблон на функция `derivative`, която приема функция на 1 аргумент и връща нова функция на 1 аргумент, която е производната на подадената функция.

### Пример:
```c++
std::cout << derivative<double>([](double x){ return x * x;})(5) << '\n'; // -> ~10
```

## Задача 05 - Принтиране
Напишете шаблон на функция `print`, която приема масив и извежда елементите на масива на стандартния изход.

### Пример:
```c++
int arr[] = {1, 2, 3, 4};
print(arr, 4); // -> 1 2 3 4
```

## Задача 06 - Map
Напишете шаблон функция `map`, която приема масив от тип `T` и функция, която приема аргумент от тип `T` и връща резултат от тип `U`. Функцията `map` да връща нов масив, съставен от елементите на подадения масив след прилагането на подадената функция над тях.

### Пример:
```c++
int arr[] = {1, 2, 3, 4};
int* result = map<int, int>(arr, 4, [](int element){ return element * element;});

print(result, 4); // -> 1 4 9 16

delete[] result;
```

## Задача 07 - Filter
Напишете шаблон на функция `filter`, която приема масив от тип `T` и функция, която приема аргумент от тип `T` и връща резултат от тип `bool`. Функцията `filter` да връща нов масив, съставен от тези елементи от подадения масив, върху които като приложим подадената функция, получаваме резултат `true`.

### Пример:
```c++
int arr[] = {1, 2, 3, 4};
int* result = filter<int>(arr, 4, [](int element){ return element % 2 == 0;});

print(result, 2); // -> 2 4

delete[] result;
```

## Задача 08* - Reduce
Напишете шаблон на функция `reduce`, която приема функция на 2 аргумента - първият от тип `T`, вторият от тип `U`, начална стойност от тип `U` и масив от тип `T`. Функцията `reduce` да реализира дясно свиване ([right fold](https://en.wikipedia.org/wiki/Fold_(higher-order_function))) на подадения масив.

### Пример:
```c++
int arr[] = {1, 2, 3, 4, 5};
std::cout << reduce<int, int>([](int curr, int res){
    return res * curr;
}, 1, arr, 5) << '\n'; // -> 120
```

## Задача 09 - Сума на нечетни квадрати
Напишете функция `sum_odd_squares`, която приема масив от цели числа и която намира сумата на тези квадрати на елементите в масива, които са нечетни числа. За решението използвайте `map`, `filter` и `reduce`.

### Пример:
```c++
int arr[] = {1, 2 ,3 , 4, 5, 6, 7, 8, 9, 10};
std::cout << sum_odd_squares(arr, 10) << '\n'; // -> 165
```

## Задача 10 - All/Any
Напишете шаблони на функции `all/any`, които приемат функция на 1 аргумент от тип `T`, която връща стойност от тип `bool`, и масив от елементи от тип `T`. Функциите `all/any` да връщат `true`, когато подадената функция връща истина за всички елементи/за някой елемент на масива.

### Пример:
```c++
int arr[] = {1, 2, 3, 4, 5};

std::cout << std::boolalpha << all<int>([](int x){ return x % 2 == 0; }, arr, 5) << '\n'; // -> false
std::cout << std::boolalpha << any<int>([](int x){ return x % 2 == 0; }, arr, 5) << '\n'; // -> true
```

## Задача 11 - Сортиране спрямо критерий
Напишете шаблон на функция `sort_by`, която приема функция `cmp` на 2 аргумента от тип `T`, която връща стойност от тип `bool` и масив от елементи от тип `T`. Функцията `sort_by` да сортира масива, като вместо `<` да ползва `cmp` за сравнение на елементите.

### Пример:
```c++
int arr[] = {1, 2, 3, 4, 5};
sort_by<int>([](int a, int b){
    return a <= b;
}, arr, 5);

print(arr, 5); // -> 1 2 3 4 5

sort_by<int>([](int a, int b){
    return a > b;
}, arr, 5);

print(arr, 5); // -> 5 4 3 2 1
```