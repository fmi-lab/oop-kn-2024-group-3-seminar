# Седмица 06 - Шаблони на класове

## От шаблони на функции към шаблони на класове
Идеята за дефиниции на функции, които не зависят от типовете на аргументите и резултата си, се пренася директно и към класовете. Например класът `Vector`, представляващ динамичен масив, би имал абсолютно същата реализация за всеки един тип, понеже всички операции в него по никакъв начин не разчитат на конкретни свойства на типа на елементите в масива. Решението на този проблем, също както при функции, е чрез шаблони. Дефиницията на един шаблонен клас е аналогична на тази на шаблонните функции:

```c++
template <typename T>
class Vector {
public:
  explicit Vector(std::size_t capacity = 0);
  Vector(const Vector& other);
  ~Vector();
  Vector& operator=(const Vector& other);

  void push_back(const T& element) noexcept;
  const T& operator[](std::size_t index) const;
  T& operator[](std::size_t index);
  std::size_t length() const noexcept;

private:
  T* data;
  std::size_t size, capacity;
};
```

Типовият параметър може да се ползва както за типовете на член-данните, така и за типовете на аргументите и резултата на методите. Също както шаблоните на функции, шаблоните на класове не са истински класове, а са по-скоро инструкции за компилатора как трябва да изглеждат класовете. Когато използваме шаблона с конкретен тип, се генерира нов клас, при който типовият параметър е заменен с конкретния тип и чак тогава можем да създаваме инстанции от този клас. Когато създаваме обекти от шаблонен клас, трябва задължително да подаваме типа на параметъра. Да разгледаме пример как се създават обекти от шаблонен клас:

```c++
int main() {
  Vector<int> vector;

  vector.push_back(3);
  vector.push_back(7);
  vector.push_back(5);
  vector.push_back(2);

  for(std::size_t i = 0; i < vector.length(); ++i) {
    std::cout << vector[i] << ' ';
  }
  std::cout << '\n';
 
  return 0;
}
```

## Шаблони и разделна компилация
Както стана въпрос по-горе, шаблоните на класове не се компилират, а по време на изпълнение се създават конкретни класове с конкретни типове, когато имаме нужда от тях, т.е. когато създаваме обекти от дадения клас с конкретен типов параметър. Но това означава, че разделната компилация в случая е невъзможна. Дори да разделим класа на дефиниция в заглавен файл и реализация в `cpp` файл и компилираме файла с реализация ние няма да сме "компилирали шаблона". Даже напротив - разделянето на класа на две части в случая води до сериозни проблеми. Те са свързани с това, че когато изпълним програмата и се опитаме да създадем обект от шаблонен клас с конкретен типов параметър, компилаторът ще "види" `include`-натия заглавен файл с дефиницията на класа и ще създаде дефинция с конкретния тип, но понеже няма достъп до `cpp` файла, няма да знае как да създаде реализации на методите на класа и той ще си остане само с дефиниции. Дори и да компилираме `cpp` файла, понеже шаблоните не се компилират, пак няма да имаме реализации на методите за конкретния тип. Затова, когато пишем шаблони на класове, трябва **дефиницията на класа и реализацията на методите му да са в един заглавен файл**. Като компромисен вариант, можем да направим реализациите на методите извън дефиницията на класа, за да може тя да е ясна и изчистена. В примера от по-горе това би изглеждало така:

```c++
template <typename T>
Vector<T>::Vector(std::size_t capacity) {
  // code goes here...
}

template <typename T>
Vector<T>::Vector(const Vector &other)  {
  // code goes here...
}

template <typename T>
Vector<T>::~Vector() {
  delete[] data;
}

template <typename T>
Vector<T> &Vector<T>::operator=(const Vector &other) {
  //code goes here...
}

template <typename T>
void Vector<T>::push_back(const T &element) noexcept {
  //code goes here...
}

// more methods...
```

Обърнете внимание, че за всеки метод трябва да укажем, че е шаблон и трябва да подадем типовия параметър при указване на областта, от която взимаме методите. Типовият параметър трябва да се указва и когато връщаме като резултат от метода обект от типа на класа, но може да бъде пропуснат на местата, където подаваме обект от типа на класа като параметър.

## Особености на шаблоните на класове
Шаблоните в C++ са известни с това, че ако не се внимава с тяхната употреба, могат да доведат до много проблеми, които се откриват трудно, и до крайно нечетими грешки при компилация. Вече разгледахме един от най-честите проблеми при шаблоните, а именно невъзможността за разделна компилация, но има още доста тънки моменти, които си струва да се обсъдят. Ще се спрем на два от по-често срещаните проблеми:
- некоректни типови параметри - в някои случаи, в някой от методите на шаблонния клас използваме операция върху обекти от типа на типовия параметър, които не се поддържат от всички типове. Пример за това е сравнението на обекти с оператора `==`. Ако подадем като типов параметър тип, който няма предефиниран операторът `==` няма да получим компилационна грешка, но по време на изпълнение ще получим грешка, че се опитваме да използваме `==` над обекти, които не го поддържат. За съжаление, грешките които получава са твърде нечетими и този проблем трудно може да се хване. За щастие от С++ 20 има решение на този проблем, чрез [concepts and constraints](https://en.cppreference.com/w/cpp/language/constraints), които ни помагат да наложим ограничения на типовите параметри, така че да получим компилационна грешка, ако подадем тип, който не поддържа дадена операция;
- реализация на приятелски функции извън дефиницията на шаблонния клас - понеже приятелските функции не са част от класа, то ако те използват по някакъв начин типовия параметър в себе си, когато ги реализираме извън класа те няма да зная от къде да вземат този параметър. Тук има 2 решения на проблема - единият е да дефинираме функцията по-рано извън класа, после отново я дефинираме в класа и накрая я реализираме отново извън класа. Другият подход е като направим самата функция шаблонна вътре в класа спрямо друг типов параметър и използваме него, вместо този за целия клас. Така функцията вече знае, че типовият параметър си е неин и няма да имаме проблеми при линкването на дефиницията и реализацията;

Част от компаниите забраняват употребата на шаблони именно поради това, че пораждат доста проблеми, които могат да отнемат изключително много време, докато се открият. Други пък насърчават силно употребата на шаблони, дори на места където на пръв поглед няма нужда от тях. Изобщо шаблоните са полезен инструмент, който обаче е нож с 2 остриета, който разделя мненията на хората и до ден днешен.

## Задача 01 - Релация
Да се реализира клас `Relation`, който представлява релация между 2 обекта от еднакъв тип. Релацията трябва да съдържа два обекта - `subject`  и `object`, и символен низ с произволна дължина, описващ връзката между тези обекти. Да се реализират оператор за изход и оператор *, който представлява композиция на 2 релации (композиция се допуска само, ако `object` обекта на първата релация е равен на `subject` обекта на втората).

### Пример:
```c++
Relation<int> r1(2,6,"is smaller than"),r2(6,3,"is divisible by");
r1.print(); //2 is smaller than 6
(r1*r2).print(); //2 is smaller than 6, which is divisible by 3
```

## Задача 02 - Сортиран масив
Да се реализира клас `Sorted`, който представлява сортиран масив от елементи от произволен тип. Да се реализират два конструктора - един без параметри, който създава нов празен сортиран масив, и един, който приема като параметър масив, и създава сортирана версия на подадения. Освен това да се реализират следните методи:
- add - добавя нов елемент в масива;
- remove - премахва елемент от масива;
- operator[] - връща елемента на подадения индекс. Да се реализира константна и неконстантна версия;
- size - връща размера на масива;
- filter - по подаден предикат, премахва всички елементи от масива, които не отговарят на предиката;
- map - по подадена функция прилага функцията над всеки от елементите;
- search - проверява дали подаденият елемент е в масива. Да се реализира чрез метода на двоичното търсене.

### Подсказка:
Уверете се, че след извикването на `map`, масивът продължава да е сортиран.

## Задача 03 - Книга с контакти
Да се реализира клас `Dictionary`, който представлява речник. За речника може да си мислим като списък от наредени двойки, където първата компонента на двойката е от тип K и я наричаме ключ, а втората е от тип V и я наричаме стойност. На всеки ключ се съпоставя точно 1 стойност. Да се реализират следните методи:
- add - по подаден ключ и стойност ги добавя на края на речника, само ако в речника не съществува друг елемент със същия ключ;
- remove - по подаден ключ, премахва него и съответната му стойност;
- search - по подаден ключ връща съответната му стойността. Помислете какво трябва да връща метода, ако не съществува елемент с подадения ключ;
- operator<< - извежда речника.

Да се реализира клас `Contact`, който представлява телефонен контакт, съдържащ име (символен низ до 100 символа), телефонен номер (точно 10 цифри) и оператор - A1, Vivacom или Yettel. Да се реализира оператор за изход.

Да се реализира клас `ContactBook`, който представлява книга с контакти, съставена от 2 речника, като ключа на първия е името на контакта, а ключа на втория е телефонният номер на контакта. Стойностите и на двата речника са **указатели** към контакти. Да се реализират следните методи:
- add - по подаден контакт, записва контакта и в двата речника (само, ако такъв контакт не съществува);
- remove - премахва контакт по име или телефонен номер;
- search - търси контакт по име или телефонен номер;
- change_operator - по подаден критерий за търсене (име или телефонен номер) и оператор, променя оператора на контакта, който отговаря на критерия;
- print - извежда книгата с контакти, подредена по имена или телефонни номера.

### Обяснение:
В книгата с контакти, стойностите на речниците са указатели, за да може, независимо в кой от тях извършваме операциите, да ги извършваме върху един и същ контакт и промените да се отразяват и в двата речника. Методите, които приемат име или телефонен номер могат да се претоварят така, че едната версия да приема символен низ (име), а другата - масив от 10 цифри (телефонен номер). Избрано е това представяне, а не един масив от контакти, за да свикнем с указателите към обекти и управлението на споделена памет.

### Бонус:
При метода `add`, да се създава копие на подадения контакт в динамичната памет (чрез `new`) преди да бъде добавен в речниците.