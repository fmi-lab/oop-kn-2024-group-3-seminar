# Седмица 16 - Move семантики

## Видове стойности в C++
В C++, всеки израз се характеризира по 2 начина - спрямо типа на израза и спрямо вида на стойността на израза. До сега сме говорили само за 2 вида стойности - `lvalue` и `rvalue`, но се оказва, че това не е най-правилното разделение на типовете стойности и затова сега ще разгледаме в детайли всички видове:
- `prvalue` (pure rvalue) - това са литералите (без низовете), ламбда функциите и резултатите от функции или оператори, чиито тип не е референция към друг обект (т.е. когато връщаме копия);
- `lvalue` - това са всички "именовани" обекти (променливи, функции, член-данни), низовите литерали и резултатите от функции или оператори, чиито тип е референция към друго `lvalue`;
- `xvalue` (eXpiring value) - това са временни обекти, чиито ресурси могат да бъдат преизползвани (преместени). Такива обекти получаваме, когато резултата на израза е т.нар. `rvalue reference` или когато резултата е `prvalue`, който обаче се каства към `rvalue reference`. `Rvalue reference` е референция към `rvalue`, която удължава живота на `rvalue` обекта, към който сочи, докато самата референция не бъде унищожена. Това означава, че временните обекти също имат място в паметта, което може да се достъпи чрез тези `rvalue references`;
- `glvalue` (generalized lvalue) - `lvalue` или `xvalue`;
- `rvalue` - `prvalue` или `xvalue`;

Новото, с което се сблъскваме в горния списък, са `xvalue` стойностите и в частност - `rvalue references`. За да декларираме `rvalue reference` трябва да използваме `&&` в декларацията на типа. Също така можем да използваме `std::move`, за да превърнем `lvalue` в `xvalue`. Ето няколко примера за създаване на `rvalue references`:

```c++
void foo(int&& a) {
  std::cout << a << '\n';
}

int bar() {
  return 7;
}

int main() {
  int&& a = 5;
  int b = 9;
  int c;
  std::cin >> c;

  foo(3); // 3
  foo(bar()); // 7
  foo(std::move(b)); // 5
  foo(a); // compile-time error
  
  return 0;
}
```

## Move семантики
`rvalue references`, подобно на `lvalue references`, ни позволяват да си спестим копиранията в част от случаите когато подаваме стойности като аргументи. `rvalue references` индикират, че сочената от тях стойност може да бъде "преместена", понеже скоро ще бъде унищожена. Това преместване се обосновава на специални правила, които се наричат move семантики. Според тях, когато една функция получава като аргумент rvalue reference, стойността сочена от референцията няма да бъде копирана, но функцията може да промени (или "открадне") стойността като обаче гарантира, че тя ще продължи да бъде валидна (т.е. инвариантата за типа на тази стойност ще продължи да бъде изпълнена). Именно заради това rvalue references сочат временни обекти или обекти, които скоро ще бъдат унищожени - чрез move семантиките ние можем да преизполваме техните ресурси, вместо да ги копираме излишно. 

## Rule of 0-3-5
Вече се запознахме с rule of 0-3 или т.нар. голяма четворка. С помощта на move семантиките обаче, ние можем да разширим този идиом до rule of 0-3-**5**. Двата допълнителни специални методи, които трябва да реализират нашите класове, за да спазват това правило, са move конструктор и move  assignment оператор. Те имат следната сигнатура:

```c++
class A {
  A(A&& other) noexcept;
  A& operator=(A&& other) noexcept;
};
```

Отново, както и за останалите методи от голямата четворка, ако не дефинираме изрично move конструктор и move assignment оператор, ще се създадат системни такива, които просто ще преместват директно член-данните. Тези два нови метода се използват, когато искаме нашият обект да "открадне" съдържанието на друг обект от същия клас, като не гарантира, че ще запази данните в оригиналния обект, но гарантира, че ще го остави във валидно състояние. Отново, правилото е, че ако ни се наложи да дефинираме изрично кой да е от следните 5 специални метода - конструктор за копиране, move конструктор, оператор за копиране, move assignment оператор и деструктор, то трябва изрично да дефинираме всичките 5. Тук обаче има доста случаи, в които се налага да нарушим това правило - типичен пример са класове, представляващи обекти, които не могат да се копират, но техните данни могат да се "крадат" (това са например нишки, умни указатели и др.).

## Кога да ползваме константи референции и кога - rvalue references
Естествен въпрос, който можем да си зададем е кога бихме предпочели да подаваме константни референции и кога - rvalue referencse. Като насоки, можем да използваме следните точки:

Използваме константни референции, когато:
- искаме да си спестим копирането на големи обекти в паметта, които ще продължат да се ползват в програмата.
- не искаме да променяме обектите или искаме да запазим данните в тях;
- искаме да върнем като стойност на функция съществуващ обект, но не искаме той да бъде променян;

Използваме rvalue references, когато:
- искаме да си спестим копирането на големи временни обекти;
- искаме да "откраднем" стойността, сочена от референцията;
- не искаме да правим дълбоки копия на обектите, а само да "преместим" данните от един обект в друг, понеже вторият вече е ненужен.

Разбира се, този списък не е изчерпателен, но е добра насока, когато се чудим кой от двата варианта да използваме.

## Задача 01 - Разширение на класове
За следните класове добавете и move контруктор и move assignment operator:
- класа `Student` от седмица 03;
- класа `Sorted` от седмица 06;
- класа `LinkedList` от седмица 13;

## Задача 02 - Unique Pointer
В стандартната библиотека на C++ има няколко класа, които имат общото име `smart pointers`. Това са такива класове, които "обвиват" нормалните указатели и правят работата с тях доста по-лесна. Един такъв `smart pointer` е `std::unique_ptr`. Той представлява `RAII` контейнер за указателите, т.е. грижи се затова да няма споделяне на памет и за унищожаването на паметта, заделена от указателя. За да се гарантира първото, конструктора за копиране и операторът за присвояване са изтрити. Ако искаме да създадем нов `std::unique_ptr`, който съдържа същия указател, трябва да използваме move конструктора или move assignment оператора, които ще "откраднат" указателя от първоначалния `std::unique_ptr`. Задачата ви е да имплементирате своя версия на този `smart pointer` като имате предвид горните особености. Освен това реализирайте и следните оператори:
- операторите * и -> за достъп до обекта, сочен от указателя;
- оператор [] за индексиран достъп, ако подаденият указател сочи към динамично заделен масив;
- други методи и оператори, които сметнете, че е добре да има.

## Задача 03 - File Handle
Напишете `RAII` контейнер, подобен на `unique pointer`, който се грижи за правилното управление на файлов поток. Помислете кои конструктори и оператори от `rule of 5` трябва да реализирате за този клас. Като допълнение, реализирайте и следните методи:
- write - записва символен низ във файла;
- read - прочита определен брой символи от файла;
- getline - прочита символи от файла до срещането на подаден разделител или до достигане на подадения брой символи;
- ignore - прочита и изхвърля символи до срещането на подаден разделител или до достигане на подадения брой символи;