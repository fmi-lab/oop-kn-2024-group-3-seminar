# Седмица 02 - Класове

## Контрол на достъпа
До сега използвахме структурите, за да групираме няколко променливи заедно, така че да може по-лесно да изпълняваме някакви операции върху тях. В много случаи освен, че искаме просто да групираме няколко променливи, искаме и да е спазен някакъв инвариант за структурата - това е някакво свойство или ограничение, което трябва да е спазено през цялото време на изпълнение на програмата. Нека си представим, че искаме да направим структура, която представлява рационално число:
```c++
struct Rational {
  int numerator;
  int denominator;
};
```

Нормално е в този случай да искаме знаменателя да е различен от 0 във всеки един момент от изпълнението на програмата. Проблемът е, че в момента по всяко време може да променим свободно знаменателя на каквато си искаме стойност, включително 0. За да предотвратим това, трябва да укажем кои член-данни на структурата мога да се достъпват свободно и кои - не. Това става с ключовите думи `public` и `private`:
- `public` позволява свободно достъпа до член-данните;
- `private` забранява достъпа до член-данните.

Тези ключови думи се наричат спецификатори за достъп (`access modifiers`). Не е нужно да ги слагаме преди всяка член-данна: те важат за всяка член-данна, дефинирана след тях, до срещането на друг спецификатор за достъп.

Сега нашата структура би изглеждала така:
```c++
struct Rational {
private:
  int numerator;
  int denominator;
};
```

Проблемът сега е, че нямаме никакъв достъп до член-данните и не можем да напишем функции, които да ги ползват. Това, което можем да направим обаче е да направим методи - това са функции, които са част от структурата и имат свободен достъп до всички член-данни, независимо дали са `public` или `private`. Нека да направим няколко метода за работа с рационално число:

```c++
struct Rational {
public:
  int getNumerator() {
    return numerator;
  }

  int getDenominator() {
    return denominator;
  }

  void setNumerator(int n) {
    numerator = n;
  }

  void setDenominator(int n) {
    if(n != 0) {
      denominator = n;
    }
  }

private:
  int numerator;
  int denominator;
};
```

Методите `getNumerator` и `getDenominator` се наричат селектори - чрез тях достъпваме член-данните за "четене" (т.е. не можем да ги модифицираме). Методите `setNumerator` и `setDenominator` се наричат мутатори - чрез тях променяме член-данните. Обърнете внимание на проверката за 0 във `setDenominator` - тя ни гарантира, че инвариантът е винаги спазен, т.е. няма как знаменателят да стане равен на 0. Свойството на обектите да ограничават директния достъп до член-данните си, за да бъде спазен някакъв инвариант, се нарича енкапсулация и това е един от основните принципи на ООП.

## Класове vs Структури
Когато моделираме някакви обекти от реалния свят, няма да използваме структури, а ще ползваме класове. Между структурите и класовете има само 1 разлика: по подразбиране, член-данните в структурите са `public`, а в класовете са `private` (и въпреки това ще продължим изрично да слагаме `private`, за да е по-прегледен кода). По принцип е общо прието класовете да се ползват за някакви големи обекти с много член-данни и методи, а структурите да се ползват за т.нар. `plain old objects` - това са групирани променливи без ограничение на достъпа до тях и без методи. В такъв случай, ако вземем последния пример и заменим думата `struct` с думата `class`, то официално ще сме написали първия си клас:

```c++
class Rational {
public:
  int getNumerator() {
    return numerator;
  }

  int getDenominator() {
    return denominator;
  }

  void setNumerator(int n) {
    numerator = n;
  }

  void setDenominator(int n) {
    if(n != 0) {
      denominator = n;
    }
  }

private:
  int numerator;
  int denominator;
};
```

## Конструктури (въведение)
Все още има един проблем, с който трябва да се справим: когато създавам обект от тип `Rational`, трябва задължително да извикаме `setNumerator` и `setDenominator` или иначе ще имаме някакви произволни числа за числител и знаменател. Тук на помощ идват конструктурите - това са специални методи на класовете, които се извикват при създаването на обекти от дадения клас. В случая искаме всеки път, когато създаваме обект от тип `Rational`, да дадем начални стойности за числителя и знаменателя. Ето как да напишем такъв конструктор:

```c++
class Rational {
public:
  Rational(int _numerator, int _denominator) {
    setNumerator(_numerator);
    setDenominator(_denominator);
  }

  int getNumerator() {
    return numerator;
  }

  int getDenominator() {
    return denominator;
  }

  void setNumerator(int n) {
    numerator = n;
  }

  void setDenominator(int n) {
    if(n != 0) {
      denominator = n;
    }
  }

private:
  int numerator;
  int denominator;
};
```

Конструктурите имат същото име като името на класа, в който са дефинирани, и нямат тип на върнатия резултат - той е винаги обект от текущия клас. Можем да имаме много конструктури, стига да се различават по броя или типовете на аргументите. По подразбиране, ако не сме направили нито един конструктор, се създава системен конструктор без аргументи. Можем да задаваме стойности по подразбиране на член-данните и като сложим `= {value}` на мястото на дефинициите им. Малък недостатък в някои случаи на конструкторите е, че при създаване на обект от даден клас, първо се дават стойности на член-данните и след това се извиква тялото на конструктора. Това означава, че в нашия пример, има много кратък момент, в който числителят и знаменателят имат някакви произволни стойности преди да се извика конструктора. Но тогава има един случай, в който това би нарушило инварианта - ако се окаже, че преди извикването на конструктора, знаменателят е равен на 0 и се опитаме да подадем на конструктора отново знаменател 0. Тогава знаменателят ще си остане 0 и въпреки, че сме направили нужните проверки, инвариантът няма да е спазен. 

За щастие има начин да се справим и с този проблем. При дефиницията на конструктора може да дефинираме инициализиращ списък - това е списък, който задава стойности по подразбиране на член-данните, преди извикаването на тялото на конструктора. Ако кажем, че по подразбиране стойността на знаменателя е 1, то нашият пример би изглеждал така, ако използваме инициализиращ списък:

```c++
class Rational {
public:
  Rational(int _numerator, int _denominator): numerator(_numerator), denominator(1) {
    setDenominator(_denominator);
  }

  int getNumerator() {
    return numerator;
  }

  int getDenominator() {
    return denominator;
  }

  void setNumerator(int n) {
    numerator = n;
  }

  void setDenominator(int n) {
    if(n != 0) {
      denominator = n;
    }
  }

private:
  int numerator;
  int denominator;
};
```

Следващият път ще разгледаме в детайли какви други специални конструктори има, какви проблеми решават и кога да си ги пишем изрично и кога да оставим да се създадат системни конструктори.

## Указателят `this`
Във всеки метод на даден клас имаме достъп до специалния указател `this`. Това е константен указател към обекта, от който се вика метода. Всички методи на класа имат като "скрит" първи аргумент `this`. Той е "скрит", понеже не се подава при извикването на метода и не се обявява в неговата дефиниция.

## Разделна компилация
Когато пишем класове, ще ги разделяме на 2 части - дефиниция и реализация. Дефиницията представлява описание на член-данните и методите на класа, но без да даваме имплементация на методите. Дефинициите на класовете стоят в `.hpp` файлове (заглавни файлове, `header files`). Когато искаме да използваме клас, дефиниран в друг файл, то е нужно само да си вкараме дефиницията на класа чрез `#include`. Реализацията на класовете представлява имплементация на методите на класовете в отделен `.cpp` файл. За да напишем имплементация на конкретен метод на клас, трябва да използваме операторът за указване на област - `::`, за да укажем за кой точно клас правим имплементацията. 

Но защо е нужно това разделяне? За да дадем отговора на този въпрос, трябва да разберем как се компилират няколко взаимодействащи си файла. Когато един файл вкарва заглавен файл с дефиниция на клас, то той използва дефинициите като "указатели", по които да търси реализациите. За целта трябва да компилираме както файла с `main` функцията, така и файла с реализациите (заглавните файлове не се компилират). Така обаче, ако решим да направим някакви промени по реализациите, не е нужно да рекомпилираме всички файлове, а само конкретния файл с реализациите. Това е така, защото основният файл не го интересуват конкретните имплементации на методите, понеже той има достъп единствено до заглавния файл. Компилирането на отделни части от едно цялостно приложение се нарича разделна компилация.

## Задача 01 - Рационално число
Да се реализира клас `Rational`, представляващ рационално число. Да се реализират следните методи за класа:
- `simlpify` - опростява числото до несъкратима дроб;
- `plus` - по подадено рационално число, намира сумата на двете числа и запазва резултата в текущото число;
- `multiply` - същото като `plus`, но за умножение;
- `compare` - по подадено рационално число, проверява дали то е по-голяма, равно или по-малко от текущото. Да връща съответно 1, 0 или -1.  

Да се демонстрира коректността на реализацията чрез примерна програма.

## Задача 02 - Триъгълник
Да се реализира клас `Triangle`, представляващ триъгълник, който се описва чрез трите си страни. Да се реализират нужните селектори и мутатори и да се реализират следните методи:
- `area` - намира лицето на триъгълника;
- `perimeter` - намира периметъра на тригълника;
- `inscribed_circle` - намира радиуса на вписаната окръжност;
- `circumscribed_circle` - намира радиуса на описаната окръжност. 

Да се демонстрира коректността на реализацията чрез примерна програма.