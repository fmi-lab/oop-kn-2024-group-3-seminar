# Седмица 03 - Голяма четворка / Канонична форма на клас / Rule of 0-3(-5)

## Проблеми с паметта
Да разгледаме следния клас, представляващ студент в университет:
```c++
class Student {
public:
  Student(const char* name, int year, int group, int fn, double average_grade) 
    : name(new char[strlen(name)+1]{}),
      year(year),
      group(group),
      fn(fn),
      average_grade(average_grade){
    strcpy(this->name, name);
  }

  void info() const {
    std::cout << "Name: " << name << '\n'
              << "Year: " << year << '\n'
              << "Group: " << group << '\n'
              << "Faculty number: " << fn << '\n'
              << "Average grade: " << average_grade << '\n';
  }

private:
  char* name;
  int year, group, fn;
  double average_grade;
};

int main() {
  Student student("Ivan", 1, 3, 82014, 5.75);
  student.info();
  return 0;
}
```

При изпълнението на горния пример получаваме очаквания резултат - на стандартния изход се извежда пълната информация за студента. Забелязваме обаче, че в конструктора заделяме динамично памет за името на студента, но никъде не я освобождаваме - следователно имаме изтичане на памет! Това е един от много тънки моменти при работата с класове и управлението на паметта, свързана с тях. Сега ще разгледаме в детайли как да се справим със всеки един от тези проблеми.

## Деструктор
Понеже името на студента е `private` не можем директно да кажем `delete[] student.name`, когато спрем да работим с него. Как тогава можем да освободим динамично заделената памет? Тук на помощ идва деструктора на класа. Подобно на конструктора, това е специален метод на класа, който се извиква автоматично, когато се достигне края на областта, в която е дефиниран обекта от дадения клас. Ако не напишем изрично деструктор, се създава системен такъв, който обаче има празно тяло и съответно не прави нищо. Именно заради това, когато работим с динамична памет в даден клас, трябва задължително да напишем изрично деструктор, за да няма изтичане на памет. Деструктора има същото име, като името на класа (подобно на конструктора), като пред името стои символа `~`. В нашия случай, деструктора за класа `Student` изглежда така:

```c++
~Student() {
  delete[] name; 
}
```

Сега, ако отново изпълним горния пример, няма да имаме изтичане на паметта (това може да се види, ако използваме `AddressSanitizer` например). Но това не решава всичките ни проблеми с динамичната памет.

## Конструктор за копиране
Освен, че по подразбиране се създава системен конструктор без аргументи и системен конструктор, се създава и още един системен конструктор - конструктор за копиране (`copy constructor`). Той има следната сигнатура в нашия случай:

```c++
Student(const Student&);
```

Както се вижда, конструктора за копиране е просто конструктор, който има 1 аргумент - референция към константа от същия тип, като този на класа. Чрез него можем много лесно да правим копия на нашите обекти. Нека да модифицираме нашата `main` функция от примера, за да видим как се ползва:

```c++
int main() {
  Student student("Ivan", 1, 3, 82014, 5.75);
  Student copy(student);
  copy.info();
  return 0;
}
```

Ако изпълним променения код, получаваме същия резултат като преди, т.е. копирането е коректно. Това, което не е очевидно е, че отново имаме проблем с паметта - този път имаме т.нар. `double-free` - опитали сме се да изтрием една и съща памет 2 пъти. Това се получава, понеже системният конструктор за копиране копира член-данните като просто използва конструкторите им за копиране. Но в случая на името, това означава, че указателят `name` в двата обекта сочи на едно и също място в паметта и съответно при извикаване на деструктора на единия обект тази памет ще се освободи и когато се извика деструктора на втория обект ще се опитаме да освободим същата тази памет. За да нямаме този проблем, трябва изрично да си напишем свой собствен конструктор за копиране, който прави т.нар. дълбоко копие (`deep copy`) на член-данните (това е копие, което заделя нова памет за указателите, сочещи динамично заделена памет, вместо да присвоява стойността директно). В нашия случай, конструкторът за копиране на класа `Student` изглежда така:

```c++
Student(const Student& other)
  : name(new char[strlen(other.name)+1]{}),
    year(other.year),
    group(other.group),
    fn(other.fn),
    average_grade(other.average_grade){
  strcpy(name, other.name);
}
```

Сега, ако отново изпълним горния пример, няма да имаме `double-free`. Но за съжаление, това не е единственият случай, при който можем да получим този проблем.

## Оператор за присвояване
Освен чрез конструктор за копиране, в С++ има още един начин за копиране на обекти - чрез присвояване чрез оператора `=` (`copy assignment`). В С++ можем да предефинирваме оператори, т.е. можем да променим поведението на операторите спрямо това върху какви обекти са приложени. За всички класове се създава системен оператор за присвояване, като неговата сигнатура в нашия пример е следната:

```c++
Student& operator=(const Student&);
```

Сигнатурата е подобна на тази на конструктора за копиране, с разликата, че вече имаме тип на резултата - референция от типа на обекта, за който се вика оператора. Няма да навлизаме много в детайли за операторите, понеже те са тема на следващото ни упражнение. Нека да модифицираме нашата `main` функция по следния начин:

```c++
int main() {
  Student student("Ivan", 1, 3, 82014, 5.75);
  Student copy("Petar", 2, 1, 81207, 3.45);
  copy = student;
  copy.info();
  return 0;
}
```

Ако изпълним променения код отново получаваме информация за първия студент, т.е. копирането е коректно. Обаче отново имаме същия проблем като при конструктора за копиране - получава се опит за освобождаване на вече освободена памет. Това е така, понеже системният оператор за присвояване просто извиква операторите за присвояване на член-данните и отново се оказва, че указателите `name` в двата обекта сочат към едно и също място в паметта. Заради това, отново трябва да си напишем свой оператор за присвояване, който прави дълбоко копие на член-данните. В нашия случай той изглежда така:

```c++
Student& operator=(const Student& other) {
  if(this != &other) {
    delete[] name;

    name = new char[strlen(other.name)+1]{};
    strcpy(name, other.name);
    year = other.year;
    group = other.group;
    fn = other.fn;
    average_grade = other.average_grade;
  }

  return *this;
}
```

При тази реализация има 2 ключови момента. Първият от тях е, че преди да копираме член-данните трябва да освободим паметта, заделена първоначално за тях, понеже операторът за присвояване се вика за вече конструирани обекти. Вторият е, че заради това освобождаване трябва да проверим дали не се опитваме да копираме същия обект в себе си. Това става като сравним адресите на двата обекта. Ако се окаже, че двата обекта са всъщност един и същ, то ние ще освободим паметта, заделена за член-данните и след това ще се опитаме да ги копираме в тях самите, което ще доведе до недефинирано поведение. Затова винаги трябва да имаме тази проверка в началото на тялото на оператора. Накрая връщаме модифицирания обект.

Тази реализация на оператора за присвояване обаче, както стана ясно, има доста тънки моменти, при които лесно можем да сбъркаме. Затова нека разгледаме един по-безопасен и по-лесен вариант, а именно чрез техниката `copy and swap`. При нея създаваме копие на обекта `other` чрез конструктора за копиране (като трябва да се подсигурим, че той е написан коректно) и след това правим `swap` на всички член-данни на копието с тези на нашия обект. Така нашия обект "открадва" дълбоко копираните член-данни на копието, а копието от своя страна "открадва" член-данните, включително и динамично заделените, на нашия обект. Когато се изпълни тялото на оператора за присвояване, за копието ще се извика деструктора, който автоматично ще освободи "откраднатите" член-данни, без да се налага ние да правим нещо повече. По този начин получаваме същия резултат, но с по-малко шанс за грешка. Тази реализация изглежда по следния начин:

```c++
void swap(Student& other) {
  using std::swap;

  swap(name, other.name);
  swap(year, other.year);
  swap(group, other.group);
  swap(fn, other.fn);
  swap(average_grade, other.average_grade);
}

Student& operator=(const Student& other) {
  Student copy(other);
  swap(copy);

  return *this;
}
```

Обърнете внимание на реда `using std::swap`. Той указва, че можем да ползваме `std::swap` в тялото на функцията, без да се налага да пишем `std::` (т.е. вкарваме `std::swap` в namespace-a на нашата функция). Това се прави, за да може, ако за някои от член-данните няма версия на `std::swap`, но има написана ръчно функция `swap` да не се налага пред част от тях да пишем `std::`, а пред други - не. Сега, ако изпълним отново програмата, няма да получим `double-free` и копирането ще продължи да е коректно. С това вече сме решили всички проблеми, свързани с паметта, за нашия клас (или поне всички проблеми, с които ще се сблъскаме в този курс).

## Голяма четворка
В примера разгледахме проблеми свързани с динамично заделени член-данните, но подобни проблеми могат да настъпят с всякакъв вид обекти и конструкции, за чиито жизнен цикъл трябва изрично да се грижим. Друг пример, за който знаем, са файловите потоци. Изобщо казано, когато работим с такъв вид обекти или конструкции трябва да спазваме следните 2 правила:
- ако класът няма член-данни, за чийто жизнен цикъл трябва да се грижим изрично, то тогава не пишем нито конструктор за копиране, нито оператор за присвояване, нито деструктор;
- ако обаче класът има такива член-данни, то изрично трябва да напишем и конструктор за копиране, и оператор за присвояване, и деструктор.

Случаите, в които реализираме само част от тези 3 специални метода са изключително редки и най-вероятно в курса ще видим само един такъв пример. По принцип има още 2 специални метода, които трябва да реализираме във втория случай, но за тях няма да говорим в рамките на този курс. Когато сме реализирали и трите специални метода, казваме, че имаме голяма четворка, канонично представяне или `rule-of-3` (името голяма четворка идва от това, че към тези методи се брои и обикновения конструктор).

## RAII (Resource Acquisation Is Initialization)
Разгледаните по-горе проблеми всъщност са част от един много по-голям и по-принципен проблем - проблемът за собствеността на паметта. Когато някой обект съдържа в себе си динамично заделена памет, казваме че той е собственик на тази памет. Когато обаче два обекта съдържат указатели към една и съща динамична памет, то тогава и двата обекта са собственици на паметта. Но както в реалния живот, много рядко са случаите, когато един обект си има двама собственици. Това е и идеята на принципа `RAII - Resource Acquisation is Initialization`. Той гласи, че всеки обект трябва да бъде единствен собственик на паметта, с която оперира. Тогава проблемите свързани със собствеността на паметта - кой я заделя, кой я изтрива и т.н. не могат да се случат. Ако спазваме правилата за голямата четворка, то със сигурност си гарантираме, че принципа `RAII` е изпълнен за класовете, които пишем, и това ще ни е основната цел в този курс.

## Общи изисквания за задачите:
За всяка една от задачите трябва да се погрижите за правилната работа с паметта, като приемаме че всеки обект е собственик на паметта, с която оперира.

## Задача 00 - Студент
Да се реализира клас студент, който съдържа име на студента, курс, група, факултетен номер и среден успех. Да се реализират нужните селектори и мутатори и да се реализират методи за извеждане на подробна информация за студента и за проверка дали студентът може да премине в следващ курс.

### Инвариант:
Курсът и средният успех трябва да са валидни числа, съответно от 1 до 4 и от 2 до 6.

## Задача 01 - Студент - допълнение
В класа студент от предната задача да се замени средния успех със списък от оценки. Да се добавят методи за добавяне на оценка, намиране на среден успех и намиране на броя на взетите предмети от студента.

### Бонус:
Да се използват функциите от по-висок ред от първото упражнение за реализиране на горните методи.

## Задача 02 - Пазарна количка
Да се реализира клас пазарна количка, който съдържа списък от продукти в количката. Всеки продукт съдържа име, цена за брой и количество. Да се реализират нужните селектори и мутатори. За продукта да се реализират методи за намиране на общата цена и за извеждане на подробна информация за продукта. За количката да се реализират методи за добавяне и премахване на продукт, за намиране на общата цена на продуктите в количката и за извеждане на подробна информация за количката и продуктите в нея. Да се демонстрира коректността на реализацията чрез примерна програма.

### Инвариант:
Цената и количеството на продукта трябва да са положителни. Продуктите в количката трябва да са уникални.

## Задача 03 - Списък със задачи
Да се реализира клас задача, който се описва с име, състояние (незавършена, в прогрес, завършена) и описание. Да се реализират нужните селектори и мутатори и да се реализират методи за промяна на състоянието и за извеждане на подробна информация за задачата. Да се реализира клас описващ списък от задачи. Да се реализират методи за намиране на всички задачи с дадено състояние, за добавяне, премахване и промяна на задача и за извеждане на всички задачи. Да се демонстрира коректността на реализацията чрез примерна програма.

### Инвариант:
Всяка задача в списъка трябва да има уникално име.

### Бонус: 
В описанието на задача да се добавят дата и час и за състоянието да се използва `enum class`.